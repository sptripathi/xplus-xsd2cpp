<html> 
  <head> 
    <title>Examples with Generated Source</title> 
    <meta name="Title" content="documentation">
    <meta name="Author" content="Satya Prakash Tripathi">
    <meta name="Subject" content="Examples With Generated Source">
    <meta name="Description" content="Examples With Generated Source">
    <meta name="Keywords" content="code generator, samples code generated using xsd2cpp">
    <meta name="Language" content="English">
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
  <title>Examples With Generated Source</title>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-18904337-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>  
  </head>

<h2>Examples with Generated Source <hr NOSHADE SIZE=10 WIDTH=100%> </h2> <body> <form>
The examples and generated files as of <u><i>  xsd2cpp(XmlPlus)  0.2</i></u> .<br> Many examples have been ommited to avoid verbosity. <br>(code generator:</b> <i>xsd2cpp</i>)
<ul>
<li> <a href="#examples_helloWorld">examples/helloWorld</a>
<li> <a href="#examples_simplest">examples/simplest</a>
<li> <a href="#examples_org">examples/org</a>
<li> <a href="#examples_netEnabled">examples/netEnabled</a>
</ul>
<br><br>
<h2><a name="examples_helloWorld">examples/helloWorld</a></h2>
<hr NOSHADE SIZE=2 WIDTH=100%>
<ul>
 <li> <b>XML Schema Files</b>
  <ul>
   <li> <b><a href="#examples_helloWorld_helloWorld.xsd">examples/helloWorld/helloWorld.xsd</a></b><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => Input XML Schema</code>
  </ul>
<br><br>
 <li> <b>Related XML Files</b>
  <ul>
   <li> <a href="#examples_helloWorld_valid.xml">examples/helloWorld/valid.xml</a>
  </ul>
<br><br>
 <li> <b>Files generated using <i>xsd2cpp</i></b> (along with directory structure)
  <ul>
<br>
 <li> <i>Generated Header(.h) Files</i>
  <ul>
   <li> <a href="#examples_helloWorld_include_NoNS_msg.h">examples/helloWorld/include/NoNS/msg.h</a>
   <li> <a href="#examples_helloWorld_include_NoNS_Document.h">examples/helloWorld/include/NoNS/Document.h</a>
   <li> <a href="#examples_helloWorld_include_NoNS_all-include.h">examples/helloWorld/include/NoNS/all-include.h</a>
  </ul>
<br>
 <li> <i>Generated Implementation(.cpp) Files</i>
  <ul>
   <li> <a href="#examples_helloWorld_main.cpp">examples/helloWorld/main.cpp</a>
   <li> <a href="#examples_helloWorld_src_NoNS_Document.cpp">examples/helloWorld/src/NoNS/Document.cpp</a>
  </ul>
  </ul>
<br><br>
</ul>
<h3><a name="examples_helloWorld_helloWorld.xsd">examples/helloWorld/helloWorld.xsd</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
 
 &lt;xsd:element name="msg" type="xsd:string"/&gt;

&lt;/xsd:schema&gt;

</pre>
</div>
<br><br>
<h3><a name="examples_helloWorld_valid.xml">examples/helloWorld/valid.xml</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;msg&gt;Hello World&lt;/msg&gt;</pre>
</div>
<br><br>
<h3><a name="examples_helloWorld_include_NoNS_msg.h">examples/helloWorld/include/NoNS/msg.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __NoNS_msg_H__
#define  __NoNS_msg_H__
#include "XSD/UrTypes.h"
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"



using namespace XPlus;

namespace NoNS {
    
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt; msg;
    

  //
  // Following types(mostly typedefs) are the ones, based on above C++ class definition
  // for the top-level element {http://www.w3.org/2001/XMLSchema}msg
  //


  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt; &gt; msg_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt;* msg_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt; msg; 
  
} // end namespace NoNS 
    
#endif
</pre>
</div>
<br><br>
<h3><a name="examples_helloWorld_include_NoNS_Document.h">examples/helloWorld/include/NoNS/Document.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __NoNS_DOCUMENT_H__
#define  __NoNS_DOCUMENT_H__
        
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"

#include "NoNS/msg.h"
    

using namespace XPlus;
using namespace FSM;


namespace NoNS {
    

class Document : public XMLSchema::TDocument
{
  private:
  
  
  msg_ptr _msg;
    
  AutoPtr&lt;XsdFSM&lt;msg_ptr&gt; &gt; _fsm_msg;
    
  
  // attributes, elements
  
  msg_ptr create_msg(FsmCbOptions& options);
  

  public:

  Document(bool buildTree=true, bool createSample=false);
  virtual ~Document() {}
    
  
  msg_p element_msg();
    
    
  void initFSM();
};

} // end namespace NoNS 
    
#endif
  </pre>
</div>
<br><br>
<h3><a name="examples_helloWorld_include_NoNS_all-include.h">examples/helloWorld/include/NoNS/all-include.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __NoNS_ALL_INCLUDE_H__
#define  __NoNS_ALL_INCLUDE_H__

#include "XPlus/AutoPtr.h"

  
#include "NoNS/Document.h"


using namespace XPlus;


#endif 
  </pre>
</div>
<br><br>
<h3><a name="examples_helloWorld_main.cpp">examples/helloWorld/main.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

#include "XSD/UserOps.h"
#include "NoNS/all-include.h"

void populateDocument(NoNS::Document* xsdDoc);
void updateOrConsumeDocument(NoNS::Document* xsdDoc);
    

int main (int argc, char**argv)
{
  XSD::UserOps&lt;NoNS::Document&gt;::UserOpsCbStruct cbStruct;
  cbStruct.cbPopulateDocument           =  populateDocument;
  cbStruct.cbUpdateOrConsumeDocument    =  updateOrConsumeDocument;
  

  XSD::UserOps&lt;NoNS::Document&gt; opHandle(cbStruct);
  opHandle.run(argc, argv);
}

//
// Following functions are use case templates.
// You need to put "code" in the respective contexts.
//

    

// template function to populate the Tree with values
// write code to populate the Document here
void populateDocument(NoNS::Document* xsdDoc)
{
  xsdDoc-&gt;element_msg()-&gt;stringValue("Hello World");
}

// write code to operate(update/consume/test etc.) on the Document, which is already
// populated(eg. read from an input xml file)
void updateOrConsumeDocument(NoNS::Document* xsdDoc)
{

}

  
</pre>
</div>
<br><br>
<h3><a name="examples_helloWorld_src_NoNS_Document.cpp">examples/helloWorld/src/NoNS/Document.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "NoNS/Document.h"


namespace NoNS {
    

  ///constructor for the Document node
  Document::Document(bool buildTree_, bool createSample_):
    XMLSchema::TDocument(buildTree_, createSample_)
  {
    initFSM();
    DOM::Document::attributeDefaultQualified(false);
    DOM::Document::elementDefaultQualified(false);
    
    if(buildTree()) 
    {
      
      DOMStringPtr nsUriPtr = NULL;   
      XsdEvent event(nsUriPtr, NULL, DOMString("msg"), XsdEvent::ELEMENT_START);
      if(this-&gt;createSample()) {
        event.cbOptions.isSampleCreate = true;
      }
      _fsm-&gt;processEventThrow(event); 
      
    }
    
  }

  void Document::initFSM()
  {
  
    _fsm_msg = new XsdFSM&lt;msg_ptr&gt;( Particle(NULL,  DOMString("msg"), 1, 1),  XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;msg_ptr, Document, FsmCbOptions&gt;(this, &Document::create_msg));
  
    XsdFsmBasePtr elemFsms[] = {
    _fsm_msg,
      
      NULL
    };
    XsdFsmBasePtr fofElem = new XsdFsmOfFSMs(elemFsms, XsdFsmOfFSMs::CHOICE);
    
    XsdFsmBasePtr docEndFsm = new XsdFSM&lt;void *&gt;(Particle(NULL, "", 1, 1), XsdEvent::DOCUMENT_END);
    XsdFsmBasePtr ptrFsms[] = { fofElem,  docEndFsm, NULL };
    _fsm = new XsdFsmOfFSMs(ptrFsms, XsdFsmOfFSMs::SEQUENCE);
  }

  


  /* element functions  */
  

  msg_ptr Document::create_msg(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("msg");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this, this, _fsm, options, false, false, false, "http://www.w3.org/2001/XMLSchema", "string");
    msg_p node = XSD::createElementTmpl&lt;msg, XMLSchema::Types::bt_string*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _msg = node;
      
    return node;
  }

  
  msg_p Document::element_msg()
  {
    FSM::warnNullNode(_msg, "msg", "{http://www.w3.org/2001/XMLSchema}msg", 1);
    return _msg;
  }
    
} // end namespace NoNS 
    </pre>
</div>
<br><br>
<br>
<h2><a name="examples_simplest">examples/simplest</a></h2>
<hr NOSHADE SIZE=2 WIDTH=100%>
<ul>
 <li> <b>XML Schema Files</b>
  <ul>
   <li> <b><a href="#examples_simplest_simplest.xsd">examples/simplest/simplest.xsd</a></b><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => Input XML Schema</code>
  </ul>
<br><br>
 <li> <b>Related XML Files</b>
  <ul>
   <li> <a href="#examples_simplest_nsaliases.xml">examples/simplest/nsaliases.xml</a>
   <li> <a href="#examples_simplest_valid.xml">examples/simplest/valid.xml</a>
  </ul>
<br><br>
 <li> <b>Files generated using <i>xsd2cpp</i></b> (along with directory structure)
  <ul>
<br>
 <li> <i>Generated Header(.h) Files</i>
  <ul>
   <li> <a href="#examples_simplest_include_simplest_Document.h">examples/simplest/include/simplest/Document.h</a>
   <li> <a href="#examples_simplest_include_simplest_all-include.h">examples/simplest/include/simplest/all-include.h</a>
   <li> <a href="#examples_simplest_include_simplest_items.h">examples/simplest/include/simplest/items.h</a>
  </ul>
<br>
 <li> <i>Generated Implementation(.cpp) Files</i>
  <ul>
   <li> <a href="#examples_simplest_main.cpp">examples/simplest/main.cpp</a>
   <li> <a href="#examples_simplest_src_simplest_Document.cpp">examples/simplest/src/simplest/Document.cpp</a>
   <li> <a href="#examples_simplest_src_simplest_items.cpp">examples/simplest/src/simplest/items.cpp</a>
  </ul>
  </ul>
<br><br>
</ul>
<h3><a name="examples_simplest_simplest.xsd">examples/simplest/simplest.xsd</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
  targetNamespace="http://www.example.com/simplest"
  elementFormDefault="qualified"
  &gt;

  &lt;xsd:element name="items"&gt;
    &lt;xsd:complexType mixed="true"&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="item" type="xsd:string" minOccurs="0" maxOccurs="5"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:attribute name="id" type="xsd:string" default="102" use="optional"/&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

&lt;/xsd:schema&gt;

</pre>
</div>
<br><br>
<h3><a name="examples_simplest_nsaliases.xml">examples/simplest/nsaliases.xml</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;nsaliases&gt;
  &lt;alias uri="http://www.example.com/simplest" toUrn="urn:simplest"/&gt;
&lt;/nsaliases&gt;
</pre>
</div>
<br><br>
<h3><a name="examples_simplest_valid.xml">examples/simplest/valid.xml</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;ns1:items xmlns:ns1="http://www.example.com/simplest"&gt;
  text content1
  &lt;ns1:item&gt;one&lt;/ns1:item&gt;
  text content2
  &lt;ns1:item&gt;two&lt;/ns1:item&gt;
&lt;/ns1:items&gt;</pre>
</div>
<br><br>
<h3><a name="examples_simplest_include_simplest_Document.h">examples/simplest/include/simplest/Document.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __simplest_DOCUMENT_H__
#define  __simplest_DOCUMENT_H__
        
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"

#include "simplest/items.h"
    

using namespace XPlus;
using namespace FSM;


namespace simplest{


class Document : public XMLSchema::TDocument
{
  private:
  
  
  items_ptr _items;
    
  AutoPtr&lt;XsdFSM&lt;items_ptr&gt; &gt; _fsm_items;
    
  
  // attributes, elements
  
  items_ptr create_items(FsmCbOptions& options);
  

  public:

  Document(bool buildTree=true, bool createSample=false);
  virtual ~Document() {}
    
  
  items_p element_items();
    
    
  void initFSM();
};

} // end namespace      
    
#endif
  </pre>
</div>
<br><br>
<h3><a name="examples_simplest_include_simplest_all-include.h">examples/simplest/include/simplest/all-include.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __simplest_ALL_INCLUDE_H__
#define  __simplest_ALL_INCLUDE_H__

#include "XPlus/AutoPtr.h"

  
#include "simplest/Document.h"

#include "simplest/items.h"    
  

using namespace XPlus;


#endif 
  </pre>
</div>
<br><br>
<h3><a name="examples_simplest_include_simplest_items.h">examples/simplest/include/simplest/items.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __simplest_items_H__
#define  __simplest_items_H__
#include "XSD/UrTypes.h"
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"



using namespace XPlus;

namespace simplest{


/// The class for element {}items with following structure: 
/// \n complexType-&gt;ModelGroup-or-ModelGroupDefinition
/// Read more on structures/methods inside ...
class items : public XMLSchema::XmlElement&lt;XMLSchema::Types::anyType&gt;
{
  public:

    /// constructor for the element node
    items(ElementCreateArgs args);

  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt; &gt; item_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt;* item_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt; item; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlAttribute&lt;XMLSchema::Types::bt_string&gt; &gt; attr_id_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlAttribute&lt;XMLSchema::Types::bt_string&gt;* attr_id_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlAttribute&lt;XMLSchema::Types::bt_string&gt; attr_id; 
  
  /// The MG class inside a complexType
  /// \n Refer to documentation on structures/methods inside ...
  struct sequence : public XsdSequenceFsmOfFSMs 
  {
      

    /// constructor for the MG node
    sequence(items* that);

    

    ///  For vector-element with QName "{http://www.w3.org/2001/XMLSchema}item" :
    ///  \n Returns the list of the element nodes
    ///  @return the list of element nodes fetched
    List&lt;item_ptr&gt; elements_item();

    ///  For vector-element with QName "{http://www.w3.org/2001/XMLSchema}item" :
    ///  \n Returns the element node at supplied index
    ///  @param idx index of the element to fetch 
    ///  @return the element node fetched
    item_p element_item_at(unsigned int idx);

        
        

    ///  For vector-element with QName "{http://www.w3.org/2001/XMLSchema}item" :
    ///  \n Sets the value of the element at the supplied index with the supplied value
    ///  @param idx index of the element 
    ///  @param val the value(as DOMString) to set with 
    void set_item(unsigned int idx, DOMString val);

    ///  For vector-element with QName "{http://www.w3.org/2001/XMLSchema}item" :
    ///  \n Returns the value of the element at the supplied index with the supplied value.
    ///  @param idx index of the element 
    ///  @return the value(as DOMString) of the element 
    DOMString get_item_string(unsigned int idx);


          

    ///  For vector-element with QName "{http://www.w3.org/2001/XMLSchema}item" :
    ///  \n Adds one element to the end of the "list of the element nodes"
    ///  @return the pointer to the added element
    item_p add_node_item();

    ///  For vector-element with QName "{http://www.w3.org/2001/XMLSchema}item" :
    ///  \n Sizes-up the "list of the element nodes" with the supplied size
    ///  @param size the request size(unsigned int) of the list
    ///  @return the list of "pointer-to-element-node"
    List&lt;item_ptr&gt; set_count_item(unsigned int size);


      
      
    ///  For vector-element with QName "{http://www.w3.org/2001/XMLSchema}item" :
    ///  \n Adds one element to the end of the "list of the element nodes", and sets the value with supplied DOMString value
    ///  @param val the value(as DOMString) to set with 
    void add_item_string(DOMString val);
      
        

    //  accessors for MGs/MGDs which are nested children of this MG/MGD
    

  private:  

    inline XsdFsmBase* clone() const {
      return new sequence(*this);
    }

    items*      _that;
  }; // end sequence
  

  ///  For vector-element with QName "{http://www.w3.org/2001/XMLSchema}item" :
  ///  \n Returns the list of the element nodes
  ///  @return the list of element nodes fetched
  List&lt;item_ptr&gt; elements_item();

  ///  For vector-element with QName "{http://www.w3.org/2001/XMLSchema}item" :
  ///  \n Returns the element node at supplied index
  ///  @param idx index of the element to fetch 
  ///  @return the element node fetched
  item_p element_item_at(unsigned int idx);

  

  ///  For vector-element with QName "{http://www.w3.org/2001/XMLSchema}item" :
  ///  \n Sets the value of the element at the supplied index with the supplied value
  ///  @param idx index of the element 
  ///  @param val the value(as DOMString) to set with 
  void set_item(unsigned int idx, DOMString val);

  ///  For vector-element with QName "{http://www.w3.org/2001/XMLSchema}item" :
  ///  \n Returns the value of the element at the supplied index with the supplied value.
  ///  @param idx index of the element 
  ///  @return the value(as DOMString) of the element 
  DOMString get_item_string(unsigned int idx);

        

  ///  For vector-element with QName "{http://www.w3.org/2001/XMLSchema}item" :
  ///  \n Adds one element to the end of the "list of the element nodes"
  ///  @return the pointer to the added element
  item_p add_node_item();
  
  ///  For vector-element with QName "{http://www.w3.org/2001/XMLSchema}item" :
  ///  \n Sizes-up the "list of the element nodes" with the supplied size
  ///  @param size the request size(unsigned int) of the list
  ///  @return the list of "pointer-to-element-node"
  List&lt;item_ptr&gt; set_count_item(unsigned int size);

      
      
  ///  For vector-element with QName "{http://www.w3.org/2001/XMLSchema}item" :
  ///  \n Adds one element to the end of the "list of the element nodes", and sets the value with supplied DOMString value
  ///  @param val the value(as DOMString) to set with 
  void add_item_string(DOMString val);
      
        

  ///  For the scalar-attribute with QName "{http://www.w3.org/2001/XMLSchema}id" :
  ///  \n Returns the scalar attribute node
  ///  @return the attribute node fetched
  attr_id_p attribute_attr_id();
      

  ///  For the scalar-attribute with QName "{http://www.w3.org/2001/XMLSchema}id" :
  ///  \n Sets the value of the attribute with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_attr_id(DOMString val);
  
  ///  For the scalar-attribute with QName "{http://www.w3.org/2001/XMLSchema}id" :
  ///  \n Returns the value(as DOMString) of the attribute
  DOMString get_attr_id_string();

        

  ///  For the optional scalar attribute with QName "{http://www.w3.org/2001/XMLSchema}id" :
  ///  Marks the attribute as present 
  void mark_present_attr_id();

  

  /// Returns the MG node(or node-list) inside  the complexType 
  sequence*  get_sequence() {
    return _sequence;
  }

    

  protected:
  
  XsdAllFsmOfFSMsPtr   _fsmAttrs;   
  XsdFsmBasePtr        _fsmElems;   
  
  
  AutoPtr&lt;sequence&gt; _sequence;
    
    
  List&lt;item_ptr&gt; _list_item;
            
  attr_id_ptr _attr_id;
          

  /// initialize the FSM
  void initFSM();

  
  item_ptr create_item(FsmCbOptions& options);

  attr_id_ptr create_attr_id(FsmCbOptions& options);
  

public:

  //types which this class needs, as INNER CLASSES
  
  //types which this class needs, as INNER CLASSES : END



}; //end class items

  //
  // Following types(mostly typedefs) are the ones, based on above C++ class definition
  // for the top-level element {}items
  //


  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;items &gt; items_ptr;
  /// typedef for the Plain pointer to the node
  typedef items* items_p;
  
} // end namespace      
    
#endif
</pre>
</div>
<br><br>
<h3><a name="examples_simplest_main.cpp">examples/simplest/main.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

#include &lt;iostream&gt;
#include &lt;string&gt;

extern "C" {
#include &lt;getopt.h&gt;
}
#include "simplest/all-include.h"

void populateDocument(simplest::Document xsdDoc);
void updateOrConsumeDocument(simplest::Document xsdDoc);
void writePopulatedDoc();
void writeSample();
void readUpdateWriteFile(string inFilePath);
void roundtripFile(string inFilePath);
void validateFile(string inFilePath);

void writePopulatedDoc()
{
  cout &lt;&lt; "Going to populate Document and write xml file..." &lt;&lt; endl;
  string outFile="t.xml";
  try 
  {
    simplest::Document xsdDoc(true);
    xsdDoc.prettyPrint(true);
    populateDocument(xsdDoc);
    ofstream ofs(outFile.c_str());
    ofs &lt;&lt; xsdDoc;
    cout &lt;&lt; "  =&gt; wrote file:" &lt;&lt; outFile &lt;&lt; " (using DOM Document)" 
      &lt;&lt; endl &lt;&lt; endl;

  }
  catch(XPlus::Exception& ex) {
    cerr &lt;&lt; "  =&gt; write failed" &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; "{" &lt;&lt; endl;
    cerr &lt;&lt; ex.msg();
    cerr &lt;&lt; endl &lt;&lt; "}" &lt;&lt; endl;
    exit(1);
  }
}

void writeSample()
{
  cout &lt;&lt; "writeSample:" &lt;&lt; endl;
  string outFile = "sample.xml";

  try
  {
    //write the Document back to a file
    simplest::Document xsdDoc(true, true);
    xsdDoc.prettyPrint(true);
    ofstream ofs(outFile.c_str());
    ofs &lt;&lt; xsdDoc;
    cout &lt;&lt; "  =&gt; wrote file:" &lt;&lt; outFile &lt;&lt; " (using DOM Document)" 
      &lt;&lt; endl &lt;&lt; endl;
  }
  catch(XPlus::Exception& ex) {
    cerr &lt;&lt; "  =&gt; write failed" &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; "{" &lt;&lt; endl;
    cerr &lt;&lt; ex.msg();
    cerr &lt;&lt; endl &lt;&lt; "}" &lt;&lt; endl;
    exit(1);
  }


}

void readUpdateWriteFile(string inFilePath)
{
  cout &lt;&lt; "readUpdateWriteFile:" &lt;&lt; inFilePath &lt;&lt; endl;
  cout &lt;&lt; "Going to: \n"
    &lt;&lt; "  1) read input-xml-file\n"
    "  2) update the read Document with user-supplied function updateOrConsumeDocument()\n"
    "  3) write xml file..." 
    &lt;&lt; endl &lt;&lt; endl;
  string outFile = inFilePath+ ".row.xml";
  try 
  {
    //read the file into the Document
    ifstream is(inFilePath.c_str());
    simplest::Document xsdDoc(false);
    is &gt;&gt; xsdDoc; 

    xsdDoc.prettyPrint(true);
    updateOrConsumeDocument(xsdDoc);
    
    //write the Document back to a file
    ofstream ofs(outFile.c_str());
    ofs &lt;&lt; xsdDoc;
    cout &lt;&lt; "  =&gt; wrote file:" &lt;&lt; outFile &lt;&lt; " (using DOM Document)" 
    &lt;&lt; endl &lt;&lt; endl;
  }
  catch(XPlus::Exception& ex) {
    cerr &lt;&lt; "  =&gt; write failed" &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; "{" &lt;&lt; endl;
    cerr &lt;&lt; ex.msg();
    cerr &lt;&lt; endl &lt;&lt; "}" &lt;&lt; endl;
    exit(1);
  }
}

void roundtripFile(string inFilePath)
{
  cout &lt;&lt; "Going to roundtrip file:" &lt;&lt; inFilePath &lt;&lt; endl;
  try 
  {
    //read the file into the Document
    ifstream is(inFilePath.c_str());
    simplest::Document xsdDoc(false);
    is &gt;&gt; xsdDoc; 

    //write the Document back to a file
    xsdDoc.prettyPrint(true);
    string outFile = inFilePath + ".rt.xml";
    ofstream ofs(outFile.c_str());
    ofs &lt;&lt; xsdDoc;

    cout &lt;&lt; "  =&gt; wrote file:" &lt;&lt; outFile &lt;&lt; " (using DOM Document)" 
      &lt;&lt; endl &lt;&lt; endl;
  }
  catch(XPlus::Exception& ex) {
    cerr &lt;&lt; "Error:\n" &lt;&lt; ex.msg() &lt;&lt; endl;
    exit(1);
  }
}

void validateFile(string inFilePath)
{
  cout &lt;&lt; "validating file:" &lt;&lt; inFilePath &lt;&lt; endl;
  // this is one way of validation:
  // when the Document is built from a xml-file, the file
  // does get validated. Any errors(exception) thrown, would
  // be reported in the catch block
  try
  {
    //read the file into the Document
    ifstream is(inFilePath.c_str());
    simplest::Document xsdDoc(false);
    is &gt;&gt; xsdDoc; 
  }
  catch(XPlus::Exception& ex)
  {
    ex.setContext("file", inFilePath);
    cerr &lt;&lt; "  =&gt; validation failed" &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; "Error: {" &lt;&lt; endl;
    cerr &lt;&lt; ex.msg();
    cerr &lt;&lt; endl &lt;&lt; "}" &lt;&lt; endl;
    exit(1);
  }
  catch(std::exception& ex) {
    cerr &lt;&lt; " unknown error" &lt;&lt; endl;
  }
  catch(...) {
    cerr &lt;&lt; " unknown error" &lt;&lt; endl;
  }
  cout &lt;&lt; "  =&gt; validated successfully"
    &lt;&lt; endl &lt;&lt; endl;

}

void printHelp(string argv0)
{
  cout &lt;&lt; "Usage: " &lt;&lt; argv0 &lt;&lt; " [options] XMLfiles ..." &lt;&lt; endl;
  cout &lt;&lt; "Options:" &lt;&lt; endl;  
  cout &lt;&lt; " -s, --sample\n"
    &lt;&lt; "            create a schema-driven sample xml-file\n" 
    &lt;&lt; "            Note: optional fields are omitted"
    &lt;&lt; endl;
  cout &lt;&lt; " -w, --write\n"
    &lt;&lt; "            write a xml-file using populated Document\n" 
    &lt;&lt; "            Note: populateDocument() function in main.cpp template,\n"
    &lt;&lt; "            must be used to populate the Document"
    &lt;&lt; endl;
  cout &lt;&lt; " -v, --validate\n"
    &lt;&lt; "            validate input xml-file(against compiled schema)"
    &lt;&lt; endl;
  cout &lt;&lt; " -r, --roundtrip\n"
    &lt;&lt; "            roundtrip (read-&gt;write) input xml-file"
    &lt;&lt; endl;
  cout &lt;&lt; " -u, --row\n"
    &lt;&lt; "         perform read-&gt;update-&gt;write operations on input xml-file"
    &lt;&lt; endl;
  cout &lt;&lt; " -h, --help\n"
    &lt;&lt; "         print help"
    &lt;&lt; endl;
  cout &lt;&lt; endl;
}


int main (int argc, char**argv)
{
  int c;

  /* Flag set by ‘--verbose’. */
  int verbose_flag=0;
  string inFile;

  while (1)
  {
    static struct option long_options[] =
    {
      /* These options set a flag. */
      {"verbose", no_argument,       &verbose_flag, 1},
      /* These options don't set a flag.
         We distinguish them by their indices. */
      {"help",   no_argument,        0, 'h'},
      {"sample",     no_argument,       0, 's'},
      {"write",      no_argument,       0, 'w'},
      {"validate",   required_argument, 0, 'v'},
      {"roundtrip",  required_argument, 0, 'r'},
      {"row",        required_argument, 0, 'u'},
      {0, 0, 0, 0}
    };
    /* getopt_long stores the option index here. */
    int option_index = 0;

    c = getopt_long (argc, argv, "hr:su:v:w",
        long_options, &option_index);

    /* Detect the end of the options. */
    if (c == -1)
      break;

    switch (c)
    {
      case 0:
        /* If this option set a flag, do nothing else now. */
        if (long_options[option_index].flag != 0)
          break;
        printf ("option %s", long_options[option_index].name);
        if (optarg)
          printf (" with arg %s", optarg);
        printf ("\n");
        break;

      case 'h':
        printHelp(argv[0]);
        break;

      case 's':
        writeSample();
        break;

      case 'w':
        writePopulatedDoc();
        break;

      case 'r':
        inFile = optarg;
        roundtripFile(inFile);
        break;

      case 'v':
        inFile = optarg;
        validateFile(inFile);
        break;

      case 'u':
        inFile = optarg;
        readUpdateWriteFile(inFile);
        break;

      case '?':
        /* getopt_long already printed an error message. */
        break;

      default:
        abort();
    }
  }

  if (verbose_flag) {
    //cout &lt;&lt; "verbose flag is set" &lt;&lt; endl;;
  }

  if (optind &lt; argc)
  {
    cout &lt;&lt; "Invalid arguments: " &lt;&lt; endl;
    while (optind &lt; argc)
      cout &lt;&lt;  argv[optind++] &lt;&lt; " ";

    cout &lt;&lt; endl;
    exit(1);
  }
}



//
// Following functions are templates.
// You need to put code in the context
//



// template function to populate the Tree with values
void populateDocument(simplest::Document xsdDoc)
{
  // write code to populate the Document here
  simplest::items *pItems = xsdDoc.element_items();
  pItems-&gt;setTextAmongChildrenAt("text content1", 0);

  if(1)
  {
    pItems-&gt;add_item_string("one");
    pItems-&gt;add_item_string("two");
  }
  else
  {
    XPlus::List&lt;simplest::items::item_ptr&gt;  list_items2 = pItems-&gt;set_count_item(2);
    list_items2.at(0)-&gt;stringValue("one");
    list_items2.at(1)-&gt;stringValue("two");
  }
  pItems-&gt;setTextAmongChildrenAt("text content2", 2);
}

void updateOrConsumeDocument(simplest::Document xsdDoc)
{
  // write code to update the populated-Document here
  simplest::items *pItems = xsdDoc.element_items();
  pItems-&gt;replaceTextAt("updated text content2", 1);
}







</pre>
</div>
<br><br>
<h3><a name="examples_simplest_src_simplest_Document.cpp">examples/simplest/src/simplest/Document.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "simplest/Document.h"


namespace simplest{


  ///constructor for the Document node
  Document::Document(bool buildTree_, bool createSample_):
    XMLSchema::TDocument(buildTree_, createSample_)
  {
    initFSM();
    DOM::Document::attributeDefaultQualified(false);
    DOM::Document::elementDefaultQualified(true);
    
    if(buildTree()) 
    {
      
      DOMStringPtr nsUriPtr = new DOMString("http://www.example.com/simplest");   
      XsdEvent event(nsUriPtr, NULL, DOMString("items"), XsdEvent::ELEMENT_START);
      if(this-&gt;createSample()) {
        event.cbOptions.isSampleCreate = true;
      }
      _fsm-&gt;processEventThrow(event); 
      
    }
    
  }

  void Document::initFSM()
  {
  
    _fsm_items = new XsdFSM&lt;items_ptr&gt;( Particle(new DOMString("http://www.example.com/simplest"),  DOMString("items"), 1, 1),  XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;items_ptr, Document, FsmCbOptions&gt;(this, &Document::create_items));
  
    XsdFsmBasePtr elemFsms[] = {
    _fsm_items,
      
      NULL
    };
    XsdFsmBasePtr fofElem = new XsdFsmOfFSMs(elemFsms, XsdFsmOfFSMs::CHOICE);
    
    XsdFsmBasePtr docEndFsm = new XsdFSM&lt;void *&gt;(Particle(NULL, "", 1, 1), XsdEvent::DOCUMENT_END);
    XsdFsmBasePtr ptrFsms[] = { fofElem,  docEndFsm, NULL };
    _fsm = new XsdFsmOfFSMs(ptrFsms, XsdFsmOfFSMs::SEQUENCE);
  }

  


  /* element functions  */
  

  items_ptr Document::create_items(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("items");
    static DOMStringPtr myNsUri = new DOMString("http://www.example.com/simplest");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this, this, _fsm, options, false, false, false);
    items_p node = XSD::createElementTmpl&lt;items, void*&gt;(t);
          
    _items = node;
      
    return node;
  }

  
  items_p Document::element_items()
  {
    FSM::warnNullNode(_items, "items", "{}items", 1);
    return _items;
  }
    
} // end namespace      
    </pre>
</div>
<br><br>
<h3><a name="examples_simplest_src_simplest_items.cpp">examples/simplest/src/simplest/items.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "simplest/items.h"

namespace simplest{


  //constructor
  
  items::items(ElementCreateArgs args):
      XMLSchema::XmlElement&lt;anyType&gt;(args),
    
    _fsmElems(NULL),
    _fsmAttrs(NULL)
  
    , _sequence(new sequence(this) )
  
  {
    this-&gt;contentTypeVariety(CONTENT_TYPE_VARIETY_MIXED);
    initFSM();
    if(args.ownerDoc && args.ownerDoc-&gt;buildTree())
    {
      if(args.ownerDoc-&gt;createSample()) {
        _fsm-&gt;fireSampleEvents();
      }
      else {
        _fsm-&gt;fireRequiredEvents();
      }
    }
  }
    
  void items::initFSM()
  {
    XsdFsmBasePtr fsmsAttrs[] = {
  new XsdFSM&lt;attr_id_ptr&gt;( Particle(NULL, DOMString("id"), 0, 1, 1), XsdEvent::ATTRIBUTE, new object_unary_mem_fun_t&lt;attr_id_ptr, items, FsmCbOptions&gt;(this, &items::create_attr_id)),
  
      NULL
    };

    _fsm-&gt;replaceOrAppendUniqueAttributeFsms(fsmsAttrs);
  
    _fsm-&gt;replaceContentFsm(_sequence);
      
    _fsmAttrs = _fsm-&gt;attributeFsm();
    _fsmElems = _fsm-&gt;contentFsm();

  }

  /* element functions  */
  

  items::item_ptr items::create_item(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("item");
    static DOMStringPtr myNsUri = new DOMString("http://www.example.com/simplest");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "http://www.w3.org/2001/XMLSchema", "string");
    items::item_p node = XSD::createElementTmpl&lt;item, XMLSchema::Types::bt_string*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _list_item.push_back(node);
      
    return node;
  }

  
  items::item_p items::element_item_at(unsigned int idx)
  {
    if(idx &gt; _list_item.size()-1) {
      throw IndexOutOfBoundsException("IndexOutOfBoundsException");
    }

    return _list_item.at(idx);
  }
    
  List&lt;items::item_ptr&gt; items::elements_item()
  {
    return _list_item;
  }
    
  items::item_p items::add_node_item()
  {
    return get_sequence()-&gt;add_node_item();
  }

  List&lt;items::item_ptr&gt; items::set_count_item(unsigned int size)
  {
    return get_sequence()-&gt;set_count_item(size);
  }

        
      
    void items::add_item_string(DOMString val)
    {
      get_sequence()-&gt;add_item_string(val);
    }

          
  void items::set_item(unsigned int idx, DOMString val)
  {
    get_sequence()-&gt;set_item(idx, val);
  }

  DOMString items::get_item_string(unsigned int idx)
  {
    return get_sequence()-&gt;get_item_string(idx);
  }

            

  /* attribute  functions  */
  

  items::attr_id_ptr items::create_attr_id(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("id");
    static DOMStringPtr myNsUri = NULL;
    
    if(_attr_id) {
      return _attr_id;
    }  
    XSD::StructCreateAttrThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options);
    items::attr_id_p node = XSD::createAttributeTmpl&lt;attr_id&gt;(t);
      
    node-&gt;defaultValue("102");    
      
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _attr_id = node;
      
    return node;
  }

  
  void items::mark_present_attr_id()
  {
    if(!_attr_id)
    {
      XsdEvent event(NULL, NULL, DOMString("id"), XsdEvent::ATTRIBUTE);
      _fsmAttrs-&gt;processEventThrow(event); 
      _fsm-&gt;fsmCreatedNode(NULL);
    }
  }

  
    void items::set_attr_id(DOMString val)
    {
        
      mark_present_attr_id();
        
      attribute_attr_id()-&gt;stringValue(val);
    }

    DOMString items::get_attr_id_string()
    {
       
      return attribute_attr_id()-&gt;stringValue();
    }

    
  items::attr_id_p items::attribute_attr_id()
  {
    FSM::warnNullNode(_attr_id, "attr_id", "{http://www.w3.org/2001/XMLSchema}id", 0);
    return _attr_id;
  }
    
  //constructor
  items::sequence::sequence(items* that):
    _that(that)
  {
    XsdFsmBasePtr fsmArray[] = {
    new XsdFSM&lt;item_ptr&gt;( Particle(new DOMString("http://www.example.com/simplest"), DOMString("item"), 0, 5), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;item_ptr, items, FsmCbOptions&gt;(_that, &items::create_item)),
             
      NULL 
    } ;
    
    XsdSequenceFsmOfFSMs::init(fsmArray);
  }

      

  List&lt;items::item_ptr&gt; items::sequence::elements_item()
  {
      
    List&lt;item_ptr&gt; nodeList;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[0].get();
    if(fsm_p) 
    {
      XsdFSM&lt;item_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;item_ptr&gt; *&gt;(fsm_p);
      if(unitFsm) {
        //nodeList = unitFsm-&gt;nodeList().stl_list(); 
        nodeList = unitFsm-&gt;nodeList(); 
      }
    }
    return nodeList;
        
  }
  
  
  items::item_p items::sequence::element_item_at(unsigned int idx)
  {
    return elements_item().at(idx);
  }

    
  void items::sequence::set_item(unsigned int idx, DOMString val)
  {
    element_item_at(idx)-&gt;stringValue(val);
  }

  DOMString items::sequence::get_item_string(unsigned int idx)
  {
    return element_item_at(idx)-&gt;stringValue();
  }
      
  items::item_p items::sequence::add_node_item()
  {
    DOMStringPtr nsUriPtr = new DOMString("http://www.example.com/simplest");
    XsdEvent event(nsUriPtr, NULL, DOMString("item"), XsdEvent::ELEMENT_START, false);
    this-&gt;processEventThrow(event); 
    return elements_item().back();
  }

  List&lt;items::item_ptr&gt; items::sequence::set_count_item(unsigned int size)
  {
    if( (size &gt; 5) || (size &lt; 0)) {
      ostringstream oss;
      oss &lt;&lt; "set_count_item: size should be in range: [" &lt;&lt; 0
        &lt;&lt; "," &lt;&lt; 5 &lt;&lt; "]";
      throw IndexOutOfBoundsException(oss.str());
    }

    unsigned int prevSize = elements_item().size();
    if(size &lt; prevSize) {
      //FIXME: allow later:
      throw XPlus::RuntimeException("resize lesser than current size not allowed");
    }

    for(unsigned int j=prevSize; j&lt;size; j++) 
    {
      // pretend docBuilding to avoid computation of adding after first loop
      XsdEvent event(new DOMString("http://www.example.com/simplest"), NULL, DOMString("item"), XsdEvent::ELEMENT_START, false);
      this-&gt;processEventThrow(event); 
    }
    
    return elements_item();
  }

        
    
  void items::sequence::add_item_string(DOMString val)
  {
    this-&gt;add_node_item()-&gt;stringValue(val);
  }
          
} // end namespace      
    </pre>
</div>
<br><br>
<br>
<h2><a name="examples_org">examples/org</a></h2>
<hr NOSHADE SIZE=2 WIDTH=100%>
<ul>
 <li> <b>README files</b>
  <ul>
   <li> <a href="#examples_org_README">examples/org/README</a>
  </ul>
<br><br>
 <li> <b>XML Schema Files</b>
  <ul>
   <li> <a href="#examples_org_engg.xsd">examples/org/engg.xsd</a>
   <li> <a href="#examples_org_hr.xsd">examples/org/hr.xsd</a>
   <li> <a href="#examples_org_legal.xsd">examples/org/legal.xsd</a>
   <li> <b><a href="#examples_org_org.xsd">examples/org/org.xsd</a></b><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => Input XML Schema</code>
  </ul>
<br><br>
 <li> <b>Related XML Files</b>
  <ul>
   <li> <a href="#examples_org_valid.xml">examples/org/valid.xml</a>
  </ul>
<br><br>
 <li> <b>Files generated using <i>xsd2cpp</i></b> (along with directory structure)
  <ul>
<br>
 <li> <i>Generated Header(.h) Files</i>
  <ul>
   <li> <a href="#examples_org_include_org_hr_Document.h">examples/org/include/org_hr/Document.h</a>
   <li> <a href="#examples_org_include_org_hr_all-include.h">examples/org/include/org_hr/all-include.h</a>
   <li> <a href="#examples_org_include_org_hr_userId.h">examples/org/include/org_hr/userId.h</a>
   <li> <a href="#examples_org_include_org_hr_leaderId.h">examples/org/include/org_hr/leaderId.h</a>
   <li> <a href="#examples_org_include_org_hr_Types_Employee.h">examples/org/include/org_hr/Types/Employee.h</a>
   <li> <a href="#examples_org_include_org_hr_Types_AllEmployees.h">examples/org/include/org_hr/Types/AllEmployees.h</a>
   <li> <a href="#examples_org_include_org_hr_Types_UserIdList.h">examples/org/include/org_hr/Types/UserIdList.h</a>
   <li> <a href="#examples_org_include_org_hr_Types_UserId.h">examples/org/include/org_hr/Types/UserId.h</a>
   <li> <a href="#examples_org_include_org_engg_all-include.h">examples/org/include/org_engg/all-include.h</a>
   <li> <a href="#examples_org_include_org_engg_Types_EnggProject.h">examples/org/include/org_engg/Types/EnggProject.h</a>
   <li> <a href="#examples_org_include_org_engg_Types_EnggDept.h">examples/org/include/org_engg/Types/EnggDept.h</a>
   <li> <a href="#examples_org_include_org_organization.h">examples/org/include/org/organization.h</a>
   <li> <a href="#examples_org_include_org_Document.h">examples/org/include/org/Document.h</a>
   <li> <a href="#examples_org_include_org_all-include.h">examples/org/include/org/all-include.h</a>
   <li> <a href="#examples_org_include_org_Types_Departments.h">examples/org/include/org/Types/Departments.h</a>
   <li> <a href="#examples_org_include_org_legal_all-include.h">examples/org/include/org_legal/all-include.h</a>
   <li> <a href="#examples_org_include_org_legal_Types_LegalDept.h">examples/org/include/org_legal/Types/LegalDept.h</a>
  </ul>
<br>
 <li> <i>Generated Implementation(.cpp) Files</i>
  <ul>
   <li> <a href="#examples_org_main.cpp">examples/org/main.cpp</a>
   <li> <a href="#examples_org_src_org_hr_Document.cpp">examples/org/src/org_hr/Document.cpp</a>
   <li> <a href="#examples_org_src_org_hr_Types_AllEmployees.cpp">examples/org/src/org_hr/Types/AllEmployees.cpp</a>
   <li> <a href="#examples_org_src_org_hr_Types_UserIdList.cpp">examples/org/src/org_hr/Types/UserIdList.cpp</a>
   <li> <a href="#examples_org_src_org_hr_Types_Employee.cpp">examples/org/src/org_hr/Types/Employee.cpp</a>
   <li> <a href="#examples_org_src_org_engg_Types_EnggDept.cpp">examples/org/src/org_engg/Types/EnggDept.cpp</a>
   <li> <a href="#examples_org_src_org_engg_Types_EnggProject.cpp">examples/org/src/org_engg/Types/EnggProject.cpp</a>
   <li> <a href="#examples_org_src_org_Document.cpp">examples/org/src/org/Document.cpp</a>
   <li> <a href="#examples_org_src_org_organization.cpp">examples/org/src/org/organization.cpp</a>
   <li> <a href="#examples_org_src_org_Types_Departments.cpp">examples/org/src/org/Types/Departments.cpp</a>
   <li> <a href="#examples_org_src_org_legal_Types_LegalDept.cpp">examples/org/src/org_legal/Types/LegalDept.cpp</a>
  </ul>
  </ul>
<br><br>
</ul>
<h3><a name="examples_org_README">examples/org/README</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
INPUT_XSD=org.xsd
</pre>
</div>
<br><br>
<h3><a name="examples_org_engg.xsd">examples/org/engg.xsd</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
  xmlns:ns1="urn:org:engg"
  xmlns:ns2="urn:org:hr"
  targetNamespace="urn:org:engg"
&gt;
  &lt;xsd:import namespace="urn:org:hr" schemaLocation="hr.xsd"/&gt;

  &lt;xsd:complexType name="EnggDept"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="ns2:leaderId"/&gt;
      &lt;xsd:element name="project" type="ns1:EnggProject" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="id" type="xsd:token" use="required"/&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="EnggProject"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="ns2:leaderId"/&gt;
      &lt;xsd:element name="projectName" type="xsd:string"/&gt;
      &lt;xsd:element name="engineers" type="ns2:UserIdList"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;



&lt;/xsd:schema&gt;
</pre>
</div>
<br><br>
<h3><a name="examples_org_hr.xsd">examples/org/hr.xsd</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
  xmlns:ns1="urn:org:hr"
  targetNamespace="urn:org:hr"
&gt;

  &lt;xsd:element name="userId" type="ns1:UserId" /&gt;
  &lt;xsd:element name="leaderId" type="ns1:UserId" /&gt;

  &lt;xsd:simpleType name="UserId"&gt;
    &lt;xsd:restriction base='xsd:token'&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:complexType name="UserIdList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="ns1:userId" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="Employee"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="ns1:userId"/&gt;
      &lt;xsd:element name="name" type="xsd:string"/&gt;
      &lt;xsd:element name="title" type="xsd:string"/&gt;
      &lt;xsd:element name="joiningDate" type="xsd:date"/&gt;
      &lt;xsd:element name="reportsTo" type="ns1:UserId" minOccurs="0"/&gt;
      &lt;xsd:element name="reportees" type="ns1:UserIdList"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="AllEmployees"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="employee" type="ns1:Employee" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;


&lt;/xsd:schema&gt;

</pre>
</div>
<br><br>
<h3><a name="examples_org_legal.xsd">examples/org/legal.xsd</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
  xmlns:ns1="urn:org:legal"
  xmlns:ns2="urn:org:hr"
  targetNamespace="urn:org:legal"
&gt;
  &lt;xsd:import namespace="urn:org:hr" schemaLocation="hr.xsd"/&gt;

  &lt;xsd:complexType name="LegalDept"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="ns2:leaderId"/&gt;
      &lt;xsd:element name="legalAdvisors" type="ns2:UserIdList"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="id" type="xsd:token" use="required"/&gt;
  &lt;/xsd:complexType&gt;

&lt;/xsd:schema&gt;
</pre>
</div>
<br><br>
<h3><a name="examples_org_org.xsd">examples/org/org.xsd</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
  xmlns:ns1="urn:org"
  xmlns:ns2="urn:org:engg"
  xmlns:ns3="urn:org:legal"
  xmlns:ns4="urn:org:hr"
  targetNamespace="urn:org"
&gt;

  &lt;xsd:import namespace="urn:org:engg" schemaLocation="engg.xsd"/&gt;
  &lt;xsd:import namespace="urn:org:legal" schemaLocation="legal.xsd"/&gt;
  &lt;xsd:import namespace="urn:org:hr" schemaLocation="hr.xsd"/&gt;

  &lt;xsd:element name="organization"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="ns4:leaderId"/&gt;
        &lt;xsd:element name="name" type="xsd:string"/&gt;
        &lt;xsd:element name="departments" type="ns1:Departments"/&gt;
        &lt;xsd:element name="allEmployees" type="ns4:AllEmployees"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:attribute name="id" type="xsd:token" use="required"/&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:complexType name="Departments"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="engineering" type="ns2:EnggDept"/&gt;
      &lt;xsd:element name="legal" type="ns3:LegalDept"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

&lt;/xsd:schema&gt;
</pre>
</div>
<br><br>
<h3><a name="examples_org_valid.xml">examples/org/valid.xml</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;ns1:organization id="nasa" xmlns:ns1="urn:org" xmlns:ns2="urn:org:hr"&gt;
  &lt;ns2:leaderId&gt;jimb&lt;/ns2:leaderId&gt;
  &lt;name&gt;NASA&lt;/name&gt;
  &lt;departments&gt;
    &lt;engineering id="nasa.deperatments.engineering"&gt;
      &lt;ns2:leaderId&gt;paulb&lt;/ns2:leaderId&gt;
      &lt;project&gt;
        &lt;ns2:leaderId&gt;allenb&lt;/ns2:leaderId&gt;
        &lt;projectName&gt;The unmanned moon mission 2015&lt;/projectName&gt;
        &lt;engineers&gt;
          &lt;ns2:userId&gt;charlese&lt;/ns2:userId&gt;
          &lt;ns2:userId&gt;waynec&lt;/ns2:userId&gt;
        &lt;/engineers&gt;
      &lt;/project&gt;
      &lt;project&gt;
        &lt;ns2:leaderId&gt;leeb&lt;/ns2:leaderId&gt;
        &lt;projectName&gt;The manned moon mission 2020&lt;/projectName&gt;
        &lt;engineers&gt;
          &lt;ns2:userId&gt;peterc&lt;/ns2:userId&gt;
          &lt;ns2:userId&gt;davidc&lt;/ns2:userId&gt;
        &lt;/engineers&gt;
      &lt;/project&gt;
    &lt;/engineering&gt;
    &lt;legal id="nasa.deperatments.legal"&gt;
      &lt;ns2:leaderId&gt;donb&lt;/ns2:leaderId&gt;
      &lt;legalAdvisors&gt;
        &lt;ns2:userId&gt;danc&lt;/ns2:userId&gt;
        &lt;ns2:userId&gt;ugoc&lt;/ns2:userId&gt;
      &lt;/legalAdvisors&gt;
    &lt;/legal&gt;
  &lt;/departments&gt;
  &lt;allEmployees&gt;
    &lt;employee&gt;
      &lt;ns2:userId&gt;jimb&lt;/ns2:userId&gt;
      &lt;name&gt;Jim Barnette&lt;/name&gt;
      &lt;title&gt;org head&lt;/title&gt;
      &lt;joiningDate&gt;1978-02-11&lt;/joiningDate&gt;
      &lt;reportees&gt;
        &lt;ns2:userId&gt;paulb&lt;/ns2:userId&gt;
        &lt;ns2:userId&gt;donb&lt;/ns2:userId&gt;
      &lt;/reportees&gt;
    &lt;/employee&gt;
    &lt;employee&gt;
      &lt;ns2:userId&gt;paulb&lt;/ns2:userId&gt;
      &lt;name&gt;Paul V. Biron&lt;/name&gt;
      &lt;title&gt;Engg head&lt;/title&gt;
      &lt;joiningDate&gt;1978-02-15&lt;/joiningDate&gt;
      &lt;reportsTo&gt;jimb&lt;/reportsTo&gt;
      &lt;reportees&gt;
        &lt;ns2:userId&gt;allenb&lt;/ns2:userId&gt;
        &lt;ns2:userId&gt;leeb&lt;/ns2:userId&gt;
      &lt;/reportees&gt;
    &lt;/employee&gt;
    &lt;employee&gt;
      &lt;ns2:userId&gt;donb&lt;/ns2:userId&gt;
      &lt;name&gt;Don Box&lt;/name&gt;
      &lt;title&gt;Legal head&lt;/title&gt;
      &lt;joiningDate&gt;1978-02-15&lt;/joiningDate&gt;
      &lt;reportsTo&gt;jimb&lt;/reportsTo&gt;
      &lt;reportees&gt;
        &lt;ns2:userId&gt;danc&lt;/ns2:userId&gt;
        &lt;ns2:userId&gt;ugoc&lt;/ns2:userId&gt;
      &lt;/reportees&gt;
    &lt;/employee&gt;
    &lt;employee&gt;
      &lt;ns2:userId&gt;allenb&lt;/ns2:userId&gt;
      &lt;name&gt;Allen Brown&lt;/name&gt;
      &lt;title&gt;Proj1 head&lt;/title&gt;
      &lt;joiningDate&gt;1978-02-15&lt;/joiningDate&gt;
      &lt;reportsTo&gt;paulb&lt;/reportsTo&gt;
      &lt;reportees&gt;
        &lt;ns2:userId&gt;charlese&lt;/ns2:userId&gt;
        &lt;ns2:userId&gt;waynec&lt;/ns2:userId&gt;
      &lt;/reportees&gt;
    &lt;/employee&gt;
    &lt;employee&gt;
      &lt;ns2:userId&gt;leeb&lt;/ns2:userId&gt;
      &lt;name&gt;Lee Buck&lt;/name&gt;
      &lt;title&gt;Proj2 head&lt;/title&gt;
      &lt;joiningDate&gt;1978-02-15&lt;/joiningDate&gt;
      &lt;reportsTo&gt;paulb&lt;/reportsTo&gt;
      &lt;reportees&gt;
        &lt;ns2:userId&gt;peterc&lt;/ns2:userId&gt;
        &lt;ns2:userId&gt;davidc&lt;/ns2:userId&gt;
      &lt;/reportees&gt;
    &lt;/employee&gt;
    &lt;employee&gt;
      &lt;ns2:userId&gt;charlese&lt;/ns2:userId&gt;
      &lt;name&gt;Charles E Campbell&lt;/name&gt;
      &lt;title&gt;SMTS&lt;/title&gt;
      &lt;joiningDate&gt;1978-02-15&lt;/joiningDate&gt;
      &lt;reportsTo&gt;allenb&lt;/reportsTo&gt;
      &lt;reportees/&gt;
    &lt;/employee&gt;
    &lt;employee&gt;
      &lt;ns2:userId&gt;waynec&lt;/ns2:userId&gt;
      &lt;name&gt;Wayne Carr&lt;/name&gt;
      &lt;title&gt;SMTS&lt;/title&gt;
      &lt;joiningDate&gt;1978-02-15&lt;/joiningDate&gt;
      &lt;reportsTo&gt;allenb&lt;/reportsTo&gt;
      &lt;reportees/&gt;
    &lt;/employee&gt;
    &lt;employee&gt;
      &lt;ns2:userId&gt;peterc&lt;/ns2:userId&gt;
      &lt;name&gt;Peter Chen&lt;/name&gt;
      &lt;title&gt;SMTS&lt;/title&gt;
      &lt;joiningDate&gt;1978-02-15&lt;/joiningDate&gt;
      &lt;reportsTo&gt;leeb&lt;/reportsTo&gt;
      &lt;reportees/&gt;
    &lt;/employee&gt;
    &lt;employee&gt;
      &lt;ns2:userId&gt;davidc&lt;/ns2:userId&gt;
      &lt;name&gt;David Cleary&lt;/name&gt;
      &lt;title&gt;SMTS&lt;/title&gt;
      &lt;joiningDate&gt;1978-02-15&lt;/joiningDate&gt;
      &lt;reportsTo&gt;leeb&lt;/reportsTo&gt;
      &lt;reportees/&gt;
    &lt;/employee&gt;
    &lt;employee&gt;
      &lt;ns2:userId&gt;danc&lt;/ns2:userId&gt;
      &lt;name&gt;Dan Connolly&lt;/name&gt;
      &lt;title&gt;Legal Advisor&lt;/title&gt;
      &lt;joiningDate&gt;1978-02-15&lt;/joiningDate&gt;
      &lt;reportsTo&gt;donb&lt;/reportsTo&gt;
      &lt;reportees/&gt;
    &lt;/employee&gt;
    &lt;employee&gt;
      &lt;ns2:userId&gt;ugoc&lt;/ns2:userId&gt;
      &lt;name&gt;Ugo Corda&lt;/name&gt;
      &lt;title&gt;Legal Advisor&lt;/title&gt;
      &lt;joiningDate&gt;1978-02-15&lt;/joiningDate&gt;
      &lt;reportsTo&gt;donb&lt;/reportsTo&gt;
      &lt;reportees/&gt;
    &lt;/employee&gt;
  &lt;/allEmployees&gt;
&lt;/ns1:organization&gt;</pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_hr_Document.h">examples/org/include/org_hr/Document.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_hr_DOCUMENT_H__
#define  __org_hr_DOCUMENT_H__
        
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"

#include "org_hr/userId.h"
    
#include "org_hr/leaderId.h"
    

using namespace XPlus;
using namespace FSM;


namespace org {
      
namespace hr {
    

class Document : public XMLSchema::TDocument
{
  private:
  
  
  userId_ptr _userId;
    
  AutoPtr&lt;XsdFSM&lt;userId_ptr&gt; &gt; _fsm_userId;
  
  leaderId_ptr _leaderId;
    
  AutoPtr&lt;XsdFSM&lt;leaderId_ptr&gt; &gt; _fsm_leaderId;
    
  
  // attributes, elements
  
  userId_ptr create_userId(FsmCbOptions& options);

  leaderId_ptr create_leaderId(FsmCbOptions& options);
  

  public:

  Document(bool buildTree=true, bool createSample=false);
  virtual ~Document() {}
    
  
  void set_root_userId();
    
  void set_root_leaderId();
    
  userId_p element_userId();
  
  leaderId_p element_leaderId();
    
    
  void initFSM();
};

} // end namespace hr  
} // end namespace org
#endif
  </pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_hr_all-include.h">examples/org/include/org_hr/all-include.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_hr_ALL_INCLUDE_H__
#define  __org_hr_ALL_INCLUDE_H__

#include "XPlus/AutoPtr.h"

  
#include "org_hr/Document.h"

#include "org_hr/Types/UserId.h"    
  
#include "org_hr/Types/UserIdList.h"    
  
#include "org_hr/Types/Employee.h"    
  
#include "org_hr/Types/AllEmployees.h"    
  

using namespace XPlus;


#endif 
  </pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_hr_userId.h">examples/org/include/org_hr/userId.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_hr_userId_H__
#define  __org_hr_userId_H__
#include "XSD/UrTypes.h"
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"


#include "org_hr/Types/UserId.h"
      

using namespace XPlus;

namespace org {
      
namespace hr {
    
  typedef XMLSchema::XmlElement&lt;org::hr::Types::UserId&gt; userId;
    

  //
  // Following types(mostly typedefs) are the ones, based on above C++ class definition
  // for the top-level element {urn:org:hr}userId
  //


  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;org::hr::Types::UserId&gt; &gt; userId_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::UserId&gt;* userId_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::UserId&gt; userId; 
  
} // end namespace hr  
} // end namespace org
#endif
</pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_hr_leaderId.h">examples/org/include/org_hr/leaderId.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_hr_leaderId_H__
#define  __org_hr_leaderId_H__
#include "XSD/UrTypes.h"
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"


#include "org_hr/Types/UserId.h"
      

using namespace XPlus;

namespace org {
      
namespace hr {
    
  typedef XMLSchema::XmlElement&lt;org::hr::Types::UserId&gt; leaderId;
    

  //
  // Following types(mostly typedefs) are the ones, based on above C++ class definition
  // for the top-level element {urn:org:hr}leaderId
  //


  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;org::hr::Types::UserId&gt; &gt; leaderId_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::UserId&gt;* leaderId_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::UserId&gt; leaderId; 
  
} // end namespace hr  
} // end namespace org
#endif
</pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_hr_Types_Employee.h">examples/org/include/org_hr/Types/Employee.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_hr_types_Employee_H__
#define  __org_hr_types_Employee_H__
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"


#include "org_hr/userId.h"
      
#include "org_hr/Types/UserId.h"
      
#include "org_hr/Types/UserIdList.h"
      
using namespace XPlus; 



namespace org {
      
namespace hr {
    
namespace Types 
{
  
/// The class for complexType Employee
/// \n Refer to documentation on structures/methods inside ...
class Employee : public XMLSchema::Types::anyType
{
  public:
  //constructor
  Employee(AnyTypeCreateArgs args);

  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;org::hr::userId &gt; userId_ptr;
  /// typedef for the Plain pointer to the node
  typedef org::hr::userId* userId_p;
  
  /// typedef for the node
  typedef org::hr::userId userId; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt; &gt; name_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt;* name_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt; name; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt; &gt; title_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt;* title_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt; title; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;XMLSchema::Types::bt_date&gt; &gt; joiningDate_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_date&gt;* joiningDate_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_date&gt; joiningDate; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;org::hr::Types::UserId&gt; &gt; reportsTo_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::UserId&gt;* reportsTo_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::UserId&gt; reportsTo; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;org::hr::Types::UserIdList&gt; &gt; reportees_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::UserIdList&gt;* reportees_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::UserIdList&gt; reportees; 
  
  /// The MG class inside a complexType
  /// \n Refer to documentation on structures/methods inside ...
  struct sequence : public XsdSequenceFsmOfFSMs 
  {
      

    /// constructor for the MG node
    sequence(Employee* that);

    

    ///  For the scalar-element with QName "{urn:org:hr}userId" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    userId_p element_userId();

        

    ///  For the scalar-element with QName "{urn:org:hr}userId" :
    ///  \n Sets the value of the scalar element with the supplied value.
    ///  @param val the value(as DOMString) to set with 
    void set_userId(DOMString val);

    ///  For the scalar-element with QName "{urn:org:hr}userId" :
    ///  \n Returns the value of the scalar element 
    ///  @return the value(as DOMString) of the element 
    DOMString get_userId_string();

          

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}name" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    name_p element_name();

        

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}name" :
    ///  \n Sets the value of the scalar element with the supplied value.
    ///  @param val the value(as DOMString) to set with 
    void set_name(DOMString val);

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}name" :
    ///  \n Returns the value of the scalar element 
    ///  @return the value(as DOMString) of the element 
    DOMString get_name_string();

          

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}title" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    title_p element_title();

        

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}title" :
    ///  \n Sets the value of the scalar element with the supplied value.
    ///  @param val the value(as DOMString) to set with 
    void set_title(DOMString val);

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}title" :
    ///  \n Returns the value of the scalar element 
    ///  @return the value(as DOMString) of the element 
    DOMString get_title_string();

          

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}joiningDate" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    joiningDate_p element_joiningDate();

        

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}joiningDate" :
    ///  \n Sets the value of the scalar element with the supplied value.
    ///  @param val the value(as DOMString) to set with 
    void set_joiningDate(DOMString val);

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}joiningDate" :
    ///  \n Returns the value of the scalar element 
    ///  @return the value(as DOMString) of the element 
    DOMString get_joiningDate_string();

          

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}joiningDate" :
    ///  \n Sets the value of the scalar element with the supplied value.
    ///  @param val the value(as XPlus::Date) to set with 
    void set_joiningDate(XPlus::Date val);

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}joiningDate" :
    ///  \n Returns the value of the scalar element
    ///  @return the value(as XPlus::Date) of the element 
    XPlus::Date get_joiningDate();

          

    ///  For the scalar-element with QName "{urn:org:hr}reportsTo" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    reportsTo_p element_reportsTo();

        

    ///  For the scalar-element with QName "{urn:org:hr}reportsTo" :
    ///  \n Sets the value of the scalar element with the supplied value.
    ///  @param val the value(as DOMString) to set with 
    void set_reportsTo(DOMString val);

    ///  For the scalar-element with QName "{urn:org:hr}reportsTo" :
    ///  \n Returns the value of the scalar element 
    ///  @return the value(as DOMString) of the element 
    DOMString get_reportsTo_string();

          
    ///  For the optional scalar element with QName "{urn:org:hr}reportsTo" :
    ///  \n Marks the element as present 
    void mark_present_reportsTo();
    

    ///  For the scalar-element with QName "{urn:org:hr}reportees" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    reportees_p element_reportees();

        

    //  accessors for MGs/MGDs which are nested children of this MG/MGD
    

  private:  

    inline XsdFsmBase* clone() const {
      return new sequence(*this);
    }

    Employee*      _that;
  }; // end sequence
  

  ///  For the scalar-element with QName "{urn:org:hr}userId" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  userId_p element_userId();
      

  ///  For the scalar-element with QName "{urn:org:hr}userId" :
  ///  \n Sets the value of the element with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_userId(DOMString val);
  
  ///  For the scalar-element with QName "{urn:org:hr}userId" :
  ///  \n Returns the value(as DOMString) of the element
  DOMString get_userId_string();

        

  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}name" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  name_p element_name();
      

  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}name" :
  ///  \n Sets the value of the element with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_name(DOMString val);
  
  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}name" :
  ///  \n Returns the value(as DOMString) of the element
  DOMString get_name_string();

        

  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}title" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  title_p element_title();
      

  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}title" :
  ///  \n Sets the value of the element with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_title(DOMString val);
  
  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}title" :
  ///  \n Returns the value(as DOMString) of the element
  DOMString get_title_string();

        

  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}joiningDate" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  joiningDate_p element_joiningDate();
      

  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}joiningDate" :
  ///  \n Sets the value of the element with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_joiningDate(DOMString val);
  
  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}joiningDate" :
  ///  \n Returns the value(as DOMString) of the element
  DOMString get_joiningDate_string();

        

  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}joiningDate" :
  ///  \n Sets the value of the element with the supplied value.
  ///  @param val the value(as XPlus::Date) to set with 
  void set_joiningDate(XPlus::Date val);

  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}joiningDate" :
  ///  \n Returns the value of the element
  ///  @return the value(as XPlus::Date) of the element 
  XPlus::Date get_joiningDate();

        

  ///  For the scalar-element with QName "{urn:org:hr}reportsTo" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  reportsTo_p element_reportsTo();
      

  ///  For the scalar-element with QName "{urn:org:hr}reportsTo" :
  ///  \n Sets the value of the element with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_reportsTo(DOMString val);
  
  ///  For the scalar-element with QName "{urn:org:hr}reportsTo" :
  ///  \n Returns the value(as DOMString) of the element
  DOMString get_reportsTo_string();

        

  ///  For the optional scalar element with QName "{urn:org:hr}reportsTo" :
  ///  Marks the element as present 
  void mark_present_reportsTo();

  

  ///  For the scalar-element with QName "{urn:org:hr}reportees" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  reportees_p element_reportees();
      

  /// Returns the MG node(or node-list) inside  the complexType 
  sequence*  get_sequence() {
    return _sequence;
  }

    

  protected:
  
  XsdAllFsmOfFSMsPtr   _fsmAttrs;   
  XsdFsmBasePtr        _fsmElems;   
  
  
  AutoPtr&lt;sequence&gt; _sequence;
    
    
  userId_ptr _userId;
            
  name_ptr _name;
            
  title_ptr _title;
            
  joiningDate_ptr _joiningDate;
            
  reportsTo_ptr _reportsTo;
            
  reportees_ptr _reportees;
              

  /// initialize the FSM
  void initFSM();

  
  userId_ptr create_userId(FsmCbOptions& options);

  name_ptr create_name(FsmCbOptions& options);

  title_ptr create_title(FsmCbOptions& options);

  joiningDate_ptr create_joiningDate(FsmCbOptions& options);

  reportsTo_ptr create_reportsTo(FsmCbOptions& options);

  reportees_ptr create_reportees(FsmCbOptions& options);
  

public:

  //types which this class needs, as INNER CLASSES
  
  //types which this class needs, as INNER CLASSES : END

  

  private:
  static XSD::TypeDefinitionFactoryTmpl&lt;XmlElement&lt;Employee&gt; &gt;   s_typeRegistry;
}; //end class Employee
} // end namespace Types


} // end namespace hr  
} // end namespace org
#endif
  </pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_hr_Types_AllEmployees.h">examples/org/include/org_hr/Types/AllEmployees.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_hr_types_AllEmployees_H__
#define  __org_hr_types_AllEmployees_H__
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"


#include "org_hr/Types/Employee.h"
      
using namespace XPlus; 



namespace org {
      
namespace hr {
    
namespace Types 
{
  
/// The class for complexType AllEmployees
/// \n Refer to documentation on structures/methods inside ...
class AllEmployees : public XMLSchema::Types::anyType
{
  public:
  //constructor
  AllEmployees(AnyTypeCreateArgs args);

  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;org::hr::Types::Employee&gt; &gt; employee_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::Employee&gt;* employee_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::Employee&gt; employee; 
  
  /// The MG class inside a complexType
  /// \n Refer to documentation on structures/methods inside ...
  struct sequence : public XsdSequenceFsmOfFSMs 
  {
      

    /// constructor for the MG node
    sequence(AllEmployees* that);

    

    ///  For vector-element with QName "{urn:org:hr}employee" :
    ///  \n Returns the list of the element nodes
    ///  @return the list of element nodes fetched
    List&lt;employee_ptr&gt; elements_employee();

    ///  For vector-element with QName "{urn:org:hr}employee" :
    ///  \n Returns the element node at supplied index
    ///  @param idx index of the element to fetch 
    ///  @return the element node fetched
    employee_p element_employee_at(unsigned int idx);

        

    ///  For vector-element with QName "{urn:org:hr}employee" :
    ///  \n Adds one element to the end of the "list of the element nodes"
    ///  @return the pointer to the added element
    employee_p add_node_employee();

    ///  For vector-element with QName "{urn:org:hr}employee" :
    ///  \n Sizes-up the "list of the element nodes" with the supplied size
    ///  @param size the request size(unsigned int) of the list
    ///  @return the list of "pointer-to-element-node"
    List&lt;employee_ptr&gt; set_count_employee(unsigned int size);


      

    //  accessors for MGs/MGDs which are nested children of this MG/MGD
    

  private:  

    inline XsdFsmBase* clone() const {
      return new sequence(*this);
    }

    AllEmployees*      _that;
  }; // end sequence
  

  ///  For vector-element with QName "{urn:org:hr}employee" :
  ///  \n Returns the list of the element nodes
  ///  @return the list of element nodes fetched
  List&lt;employee_ptr&gt; elements_employee();

  ///  For vector-element with QName "{urn:org:hr}employee" :
  ///  \n Returns the element node at supplied index
  ///  @param idx index of the element to fetch 
  ///  @return the element node fetched
  employee_p element_employee_at(unsigned int idx);

  

  ///  For vector-element with QName "{urn:org:hr}employee" :
  ///  \n Adds one element to the end of the "list of the element nodes"
  ///  @return the pointer to the added element
  employee_p add_node_employee();
  
  ///  For vector-element with QName "{urn:org:hr}employee" :
  ///  \n Sizes-up the "list of the element nodes" with the supplied size
  ///  @param size the request size(unsigned int) of the list
  ///  @return the list of "pointer-to-element-node"
  List&lt;employee_ptr&gt; set_count_employee(unsigned int size);

      

  /// Returns the MG node(or node-list) inside  the complexType 
  sequence*  get_sequence() {
    return _sequence;
  }

    

  protected:
  
  XsdAllFsmOfFSMsPtr   _fsmAttrs;   
  XsdFsmBasePtr        _fsmElems;   
  
  
  AutoPtr&lt;sequence&gt; _sequence;
    
    
  List&lt;employee_ptr&gt; _list_employee;
              

  /// initialize the FSM
  void initFSM();

  
  employee_ptr create_employee(FsmCbOptions& options);
  

public:

  //types which this class needs, as INNER CLASSES
  
  //types which this class needs, as INNER CLASSES : END

  

  private:
  static XSD::TypeDefinitionFactoryTmpl&lt;XmlElement&lt;AllEmployees&gt; &gt;   s_typeRegistry;
}; //end class AllEmployees
} // end namespace Types


} // end namespace hr  
} // end namespace org
#endif
  </pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_hr_Types_UserIdList.h">examples/org/include/org_hr/Types/UserIdList.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_hr_types_UserIdList_H__
#define  __org_hr_types_UserIdList_H__
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"


#include "org_hr/userId.h"
      
using namespace XPlus; 



namespace org {
      
namespace hr {
    
namespace Types 
{
  
/// The class for complexType UserIdList
/// \n Refer to documentation on structures/methods inside ...
class UserIdList : public XMLSchema::Types::anyType
{
  public:
  //constructor
  UserIdList(AnyTypeCreateArgs args);

  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;org::hr::userId &gt; userId_ptr;
  /// typedef for the Plain pointer to the node
  typedef org::hr::userId* userId_p;
  
  /// typedef for the node
  typedef org::hr::userId userId; 
  
  /// The MG class inside a complexType
  /// \n Refer to documentation on structures/methods inside ...
  struct sequence : public XsdSequenceFsmOfFSMs 
  {
      

    /// constructor for the MG node
    sequence(UserIdList* that);

    

    ///  For vector-element with QName "{urn:org:hr}userId" :
    ///  \n Returns the list of the element nodes
    ///  @return the list of element nodes fetched
    List&lt;userId_ptr&gt; elements_userId();

    ///  For vector-element with QName "{urn:org:hr}userId" :
    ///  \n Returns the element node at supplied index
    ///  @param idx index of the element to fetch 
    ///  @return the element node fetched
    userId_p element_userId_at(unsigned int idx);

        
        

    ///  For vector-element with QName "{urn:org:hr}userId" :
    ///  \n Sets the value of the element at the supplied index with the supplied value
    ///  @param idx index of the element 
    ///  @param val the value(as DOMString) to set with 
    void set_userId(unsigned int idx, DOMString val);

    ///  For vector-element with QName "{urn:org:hr}userId" :
    ///  \n Returns the value of the element at the supplied index with the supplied value.
    ///  @param idx index of the element 
    ///  @return the value(as DOMString) of the element 
    DOMString get_userId_string(unsigned int idx);


          

    ///  For vector-element with QName "{urn:org:hr}userId" :
    ///  \n Adds one element to the end of the "list of the element nodes"
    ///  @return the pointer to the added element
    userId_p add_node_userId();

    ///  For vector-element with QName "{urn:org:hr}userId" :
    ///  \n Sizes-up the "list of the element nodes" with the supplied size
    ///  @param size the request size(unsigned int) of the list
    ///  @return the list of "pointer-to-element-node"
    List&lt;userId_ptr&gt; set_count_userId(unsigned int size);


      
      
    ///  For vector-element with QName "{urn:org:hr}userId" :
    ///  \n Adds one element to the end of the "list of the element nodes", and sets the value with supplied DOMString value
    ///  @param val the value(as DOMString) to set with 
    void add_userId_string(DOMString val);
      
        

    //  accessors for MGs/MGDs which are nested children of this MG/MGD
    

  private:  

    inline XsdFsmBase* clone() const {
      return new sequence(*this);
    }

    UserIdList*      _that;
  }; // end sequence
  

  ///  For vector-element with QName "{urn:org:hr}userId" :
  ///  \n Returns the list of the element nodes
  ///  @return the list of element nodes fetched
  List&lt;userId_ptr&gt; elements_userId();

  ///  For vector-element with QName "{urn:org:hr}userId" :
  ///  \n Returns the element node at supplied index
  ///  @param idx index of the element to fetch 
  ///  @return the element node fetched
  userId_p element_userId_at(unsigned int idx);

  

  ///  For vector-element with QName "{urn:org:hr}userId" :
  ///  \n Sets the value of the element at the supplied index with the supplied value
  ///  @param idx index of the element 
  ///  @param val the value(as DOMString) to set with 
  void set_userId(unsigned int idx, DOMString val);

  ///  For vector-element with QName "{urn:org:hr}userId" :
  ///  \n Returns the value of the element at the supplied index with the supplied value.
  ///  @param idx index of the element 
  ///  @return the value(as DOMString) of the element 
  DOMString get_userId_string(unsigned int idx);

        

  ///  For vector-element with QName "{urn:org:hr}userId" :
  ///  \n Adds one element to the end of the "list of the element nodes"
  ///  @return the pointer to the added element
  userId_p add_node_userId();
  
  ///  For vector-element with QName "{urn:org:hr}userId" :
  ///  \n Sizes-up the "list of the element nodes" with the supplied size
  ///  @param size the request size(unsigned int) of the list
  ///  @return the list of "pointer-to-element-node"
  List&lt;userId_ptr&gt; set_count_userId(unsigned int size);

      
      
  ///  For vector-element with QName "{urn:org:hr}userId" :
  ///  \n Adds one element to the end of the "list of the element nodes", and sets the value with supplied DOMString value
  ///  @param val the value(as DOMString) to set with 
  void add_userId_string(DOMString val);
      
        

  /// Returns the MG node(or node-list) inside  the complexType 
  sequence*  get_sequence() {
    return _sequence;
  }

    

  protected:
  
  XsdAllFsmOfFSMsPtr   _fsmAttrs;   
  XsdFsmBasePtr        _fsmElems;   
  
  
  AutoPtr&lt;sequence&gt; _sequence;
    
    
  List&lt;userId_ptr&gt; _list_userId;
              

  /// initialize the FSM
  void initFSM();

  
  userId_ptr create_userId(FsmCbOptions& options);
  

public:

  //types which this class needs, as INNER CLASSES
  
  //types which this class needs, as INNER CLASSES : END

  

  private:
  static XSD::TypeDefinitionFactoryTmpl&lt;XmlElement&lt;UserIdList&gt; &gt;   s_typeRegistry;
}; //end class UserIdList
} // end namespace Types


} // end namespace hr  
} // end namespace org
#endif
  </pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_hr_Types_UserId.h">examples/org/include/org_hr/Types/UserId.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef __org_hr_UserId_H__ 
#define __org_hr_UserId_H__ 

#include &lt;string&gt;
#include &lt;list&gt;

#include "DOM/DOMCommonInc.h"
#include "XSD/PrimitiveTypes.h"
#include "XSD/xsdUtils.h"
#include "XSD/PrimitiveTypes.h"


using namespace std;
using namespace XPlus;
using namespace DOM;
using namespace XMLSchema;


namespace org {
      
namespace hr {
    

namespace Types 
{
    

  /// class for simpleType with restriction on base
  class UserId : public XMLSchema::Types::bt_token
  {
  public:
    /// constructor  
    UserId(AnyTypeCreateArgs args)
    
        : bt_token(args)
      
    {
    
      this-&gt;appliedCFacets( appliedCFacets()  );
    }
    
  protected:
    
  };

} // end namespace Types

} // end namespace hr  
} // end namespace org

#endif
  </pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_engg_all-include.h">examples/org/include/org_engg/all-include.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_engg_ALL_INCLUDE_H__
#define  __org_engg_ALL_INCLUDE_H__

#include "XPlus/AutoPtr.h"

  
#include "org_hr/all-include.h"
  
#include "org_engg/Types/EnggDept.h"    
  
#include "org_engg/Types/EnggProject.h"    
  

using namespace XPlus;


#endif 
  </pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_engg_Types_EnggProject.h">examples/org/include/org_engg/Types/EnggProject.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_engg_types_EnggProject_H__
#define  __org_engg_types_EnggProject_H__
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"


#include "org_hr/leaderId.h"
      
#include "org_hr/Types/UserIdList.h"
      
using namespace XPlus; 



namespace org {
      
namespace engg {
    
namespace Types 
{
  
/// The class for complexType EnggProject
/// \n Refer to documentation on structures/methods inside ...
class EnggProject : public XMLSchema::Types::anyType
{
  public:
  //constructor
  EnggProject(AnyTypeCreateArgs args);

  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;org::hr::leaderId &gt; leaderId_ptr;
  /// typedef for the Plain pointer to the node
  typedef org::hr::leaderId* leaderId_p;
  
  /// typedef for the node
  typedef org::hr::leaderId leaderId; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt; &gt; projectName_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt;* projectName_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt; projectName; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;org::hr::Types::UserIdList&gt; &gt; engineers_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::UserIdList&gt;* engineers_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::UserIdList&gt; engineers; 
  
  /// The MG class inside a complexType
  /// \n Refer to documentation on structures/methods inside ...
  struct sequence : public XsdSequenceFsmOfFSMs 
  {
      

    /// constructor for the MG node
    sequence(EnggProject* that);

    

    ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    leaderId_p element_leaderId();

        

    ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
    ///  \n Sets the value of the scalar element with the supplied value.
    ///  @param val the value(as DOMString) to set with 
    void set_leaderId(DOMString val);

    ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
    ///  \n Returns the value of the scalar element 
    ///  @return the value(as DOMString) of the element 
    DOMString get_leaderId_string();

          

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}projectName" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    projectName_p element_projectName();

        

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}projectName" :
    ///  \n Sets the value of the scalar element with the supplied value.
    ///  @param val the value(as DOMString) to set with 
    void set_projectName(DOMString val);

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}projectName" :
    ///  \n Returns the value of the scalar element 
    ///  @return the value(as DOMString) of the element 
    DOMString get_projectName_string();

          

    ///  For the scalar-element with QName "{urn:org:hr}engineers" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    engineers_p element_engineers();

        

    //  accessors for MGs/MGDs which are nested children of this MG/MGD
    

  private:  

    inline XsdFsmBase* clone() const {
      return new sequence(*this);
    }

    EnggProject*      _that;
  }; // end sequence
  

  ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  leaderId_p element_leaderId();
      

  ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
  ///  \n Sets the value of the element with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_leaderId(DOMString val);
  
  ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
  ///  \n Returns the value(as DOMString) of the element
  DOMString get_leaderId_string();

        

  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}projectName" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  projectName_p element_projectName();
      

  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}projectName" :
  ///  \n Sets the value of the element with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_projectName(DOMString val);
  
  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}projectName" :
  ///  \n Returns the value(as DOMString) of the element
  DOMString get_projectName_string();

        

  ///  For the scalar-element with QName "{urn:org:hr}engineers" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  engineers_p element_engineers();
      

  /// Returns the MG node(or node-list) inside  the complexType 
  sequence*  get_sequence() {
    return _sequence;
  }

    

  protected:
  
  XsdAllFsmOfFSMsPtr   _fsmAttrs;   
  XsdFsmBasePtr        _fsmElems;   
  
  
  AutoPtr&lt;sequence&gt; _sequence;
    
    
  leaderId_ptr _leaderId;
            
  projectName_ptr _projectName;
            
  engineers_ptr _engineers;
              

  /// initialize the FSM
  void initFSM();

  
  leaderId_ptr create_leaderId(FsmCbOptions& options);

  projectName_ptr create_projectName(FsmCbOptions& options);

  engineers_ptr create_engineers(FsmCbOptions& options);
  

public:

  //types which this class needs, as INNER CLASSES
  
  //types which this class needs, as INNER CLASSES : END

  

  private:
  static XSD::TypeDefinitionFactoryTmpl&lt;XmlElement&lt;EnggProject&gt; &gt;   s_typeRegistry;
}; //end class EnggProject
} // end namespace Types


} // end namespace engg  
} // end namespace org
#endif
  </pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_engg_Types_EnggDept.h">examples/org/include/org_engg/Types/EnggDept.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_engg_types_EnggDept_H__
#define  __org_engg_types_EnggDept_H__
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"


#include "org_hr/leaderId.h"
      
#include "org_engg/Types/EnggProject.h"
      
using namespace XPlus; 



namespace org {
      
namespace engg {
    
namespace Types 
{
  
/// The class for complexType EnggDept
/// \n Refer to documentation on structures/methods inside ...
class EnggDept : public XMLSchema::Types::anyType
{
  public:
  //constructor
  EnggDept(AnyTypeCreateArgs args);

  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;org::hr::leaderId &gt; leaderId_ptr;
  /// typedef for the Plain pointer to the node
  typedef org::hr::leaderId* leaderId_p;
  
  /// typedef for the node
  typedef org::hr::leaderId leaderId; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;org::engg::Types::EnggProject&gt; &gt; project_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;org::engg::Types::EnggProject&gt;* project_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;org::engg::Types::EnggProject&gt; project; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlAttribute&lt;XMLSchema::Types::bt_token&gt; &gt; attr_id_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlAttribute&lt;XMLSchema::Types::bt_token&gt;* attr_id_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlAttribute&lt;XMLSchema::Types::bt_token&gt; attr_id; 
  
  /// The MG class inside a complexType
  /// \n Refer to documentation on structures/methods inside ...
  struct sequence : public XsdSequenceFsmOfFSMs 
  {
      

    /// constructor for the MG node
    sequence(EnggDept* that);

    

    ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    leaderId_p element_leaderId();

        

    ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
    ///  \n Sets the value of the scalar element with the supplied value.
    ///  @param val the value(as DOMString) to set with 
    void set_leaderId(DOMString val);

    ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
    ///  \n Returns the value of the scalar element 
    ///  @return the value(as DOMString) of the element 
    DOMString get_leaderId_string();

          

    ///  For vector-element with QName "{urn:org:engg}project" :
    ///  \n Returns the list of the element nodes
    ///  @return the list of element nodes fetched
    List&lt;project_ptr&gt; elements_project();

    ///  For vector-element with QName "{urn:org:engg}project" :
    ///  \n Returns the element node at supplied index
    ///  @param idx index of the element to fetch 
    ///  @return the element node fetched
    project_p element_project_at(unsigned int idx);

        

    ///  For vector-element with QName "{urn:org:engg}project" :
    ///  \n Adds one element to the end of the "list of the element nodes"
    ///  @return the pointer to the added element
    project_p add_node_project();

    ///  For vector-element with QName "{urn:org:engg}project" :
    ///  \n Sizes-up the "list of the element nodes" with the supplied size
    ///  @param size the request size(unsigned int) of the list
    ///  @return the list of "pointer-to-element-node"
    List&lt;project_ptr&gt; set_count_project(unsigned int size);


      

    //  accessors for MGs/MGDs which are nested children of this MG/MGD
    

  private:  

    inline XsdFsmBase* clone() const {
      return new sequence(*this);
    }

    EnggDept*      _that;
  }; // end sequence
  

  ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  leaderId_p element_leaderId();
      

  ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
  ///  \n Sets the value of the element with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_leaderId(DOMString val);
  
  ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
  ///  \n Returns the value(as DOMString) of the element
  DOMString get_leaderId_string();

        

  ///  For vector-element with QName "{urn:org:engg}project" :
  ///  \n Returns the list of the element nodes
  ///  @return the list of element nodes fetched
  List&lt;project_ptr&gt; elements_project();

  ///  For vector-element with QName "{urn:org:engg}project" :
  ///  \n Returns the element node at supplied index
  ///  @param idx index of the element to fetch 
  ///  @return the element node fetched
  project_p element_project_at(unsigned int idx);

  

  ///  For vector-element with QName "{urn:org:engg}project" :
  ///  \n Adds one element to the end of the "list of the element nodes"
  ///  @return the pointer to the added element
  project_p add_node_project();
  
  ///  For vector-element with QName "{urn:org:engg}project" :
  ///  \n Sizes-up the "list of the element nodes" with the supplied size
  ///  @param size the request size(unsigned int) of the list
  ///  @return the list of "pointer-to-element-node"
  List&lt;project_ptr&gt; set_count_project(unsigned int size);

      

  ///  For the scalar-attribute with QName "{http://www.w3.org/2001/XMLSchema}id" :
  ///  \n Returns the scalar attribute node
  ///  @return the attribute node fetched
  attr_id_p attribute_attr_id();
      

  ///  For the scalar-attribute with QName "{http://www.w3.org/2001/XMLSchema}id" :
  ///  \n Sets the value of the attribute with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_attr_id(DOMString val);
  
  ///  For the scalar-attribute with QName "{http://www.w3.org/2001/XMLSchema}id" :
  ///  \n Returns the value(as DOMString) of the attribute
  DOMString get_attr_id_string();

        

  /// Returns the MG node(or node-list) inside  the complexType 
  sequence*  get_sequence() {
    return _sequence;
  }

    

  protected:
  
  XsdAllFsmOfFSMsPtr   _fsmAttrs;   
  XsdFsmBasePtr        _fsmElems;   
  
  
  AutoPtr&lt;sequence&gt; _sequence;
    
    
  leaderId_ptr _leaderId;
            
  List&lt;project_ptr&gt; _list_project;
            
  attr_id_ptr _attr_id;
          

  /// initialize the FSM
  void initFSM();

  
  leaderId_ptr create_leaderId(FsmCbOptions& options);

  project_ptr create_project(FsmCbOptions& options);

  attr_id_ptr create_attr_id(FsmCbOptions& options);
  

public:

  //types which this class needs, as INNER CLASSES
  
  //types which this class needs, as INNER CLASSES : END

  

  private:
  static XSD::TypeDefinitionFactoryTmpl&lt;XmlElement&lt;EnggDept&gt; &gt;   s_typeRegistry;
}; //end class EnggDept
} // end namespace Types


} // end namespace engg  
} // end namespace org
#endif
  </pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_organization.h">examples/org/include/org/organization.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_organization_H__
#define  __org_organization_H__
#include "XSD/UrTypes.h"
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"


#include "org_hr/leaderId.h"
      
#include "org/Types/Departments.h"
      
#include "org_hr/Types/AllEmployees.h"
      

using namespace XPlus;

namespace org {
    

/// The class for element {}organization with following structure: 
/// \n complexType-&gt;ModelGroup-or-ModelGroupDefinition
/// Read more on structures/methods inside ...
class organization : public XMLSchema::XmlElement&lt;XMLSchema::Types::anyType&gt;
{
  public:

    /// constructor for the element node
    organization(ElementCreateArgs args);

  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;org::hr::leaderId &gt; leaderId_ptr;
  /// typedef for the Plain pointer to the node
  typedef org::hr::leaderId* leaderId_p;
  
  /// typedef for the node
  typedef org::hr::leaderId leaderId; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt; &gt; name_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt;* name_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_string&gt; name; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;org::Types::Departments&gt; &gt; departments_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;org::Types::Departments&gt;* departments_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;org::Types::Departments&gt; departments; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;org::hr::Types::AllEmployees&gt; &gt; allEmployees_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::AllEmployees&gt;* allEmployees_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::AllEmployees&gt; allEmployees; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlAttribute&lt;XMLSchema::Types::bt_token&gt; &gt; attr_id_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlAttribute&lt;XMLSchema::Types::bt_token&gt;* attr_id_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlAttribute&lt;XMLSchema::Types::bt_token&gt; attr_id; 
  
  /// The MG class inside a complexType
  /// \n Refer to documentation on structures/methods inside ...
  struct sequence : public XsdSequenceFsmOfFSMs 
  {
      

    /// constructor for the MG node
    sequence(organization* that);

    

    ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    leaderId_p element_leaderId();

        

    ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
    ///  \n Sets the value of the scalar element with the supplied value.
    ///  @param val the value(as DOMString) to set with 
    void set_leaderId(DOMString val);

    ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
    ///  \n Returns the value of the scalar element 
    ///  @return the value(as DOMString) of the element 
    DOMString get_leaderId_string();

          

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}name" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    name_p element_name();

        

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}name" :
    ///  \n Sets the value of the scalar element with the supplied value.
    ///  @param val the value(as DOMString) to set with 
    void set_name(DOMString val);

    ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}name" :
    ///  \n Returns the value of the scalar element 
    ///  @return the value(as DOMString) of the element 
    DOMString get_name_string();

          

    ///  For the scalar-element with QName "{urn:org}departments" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    departments_p element_departments();

        

    ///  For the scalar-element with QName "{urn:org:hr}allEmployees" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    allEmployees_p element_allEmployees();

        

    //  accessors for MGs/MGDs which are nested children of this MG/MGD
    

  private:  

    inline XsdFsmBase* clone() const {
      return new sequence(*this);
    }

    organization*      _that;
  }; // end sequence
  

  ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  leaderId_p element_leaderId();
      

  ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
  ///  \n Sets the value of the element with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_leaderId(DOMString val);
  
  ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
  ///  \n Returns the value(as DOMString) of the element
  DOMString get_leaderId_string();

        

  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}name" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  name_p element_name();
      

  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}name" :
  ///  \n Sets the value of the element with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_name(DOMString val);
  
  ///  For the scalar-element with QName "{http://www.w3.org/2001/XMLSchema}name" :
  ///  \n Returns the value(as DOMString) of the element
  DOMString get_name_string();

        

  ///  For the scalar-element with QName "{urn:org}departments" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  departments_p element_departments();
      

  ///  For the scalar-element with QName "{urn:org:hr}allEmployees" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  allEmployees_p element_allEmployees();
      

  ///  For the scalar-attribute with QName "{http://www.w3.org/2001/XMLSchema}id" :
  ///  \n Returns the scalar attribute node
  ///  @return the attribute node fetched
  attr_id_p attribute_attr_id();
      

  ///  For the scalar-attribute with QName "{http://www.w3.org/2001/XMLSchema}id" :
  ///  \n Sets the value of the attribute with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_attr_id(DOMString val);
  
  ///  For the scalar-attribute with QName "{http://www.w3.org/2001/XMLSchema}id" :
  ///  \n Returns the value(as DOMString) of the attribute
  DOMString get_attr_id_string();

        

  /// Returns the MG node(or node-list) inside  the complexType 
  sequence*  get_sequence() {
    return _sequence;
  }

    

  protected:
  
  XsdAllFsmOfFSMsPtr   _fsmAttrs;   
  XsdFsmBasePtr        _fsmElems;   
  
  
  AutoPtr&lt;sequence&gt; _sequence;
    
    
  leaderId_ptr _leaderId;
            
  name_ptr _name;
            
  departments_ptr _departments;
            
  allEmployees_ptr _allEmployees;
            
  attr_id_ptr _attr_id;
          

  /// initialize the FSM
  void initFSM();

  
  leaderId_ptr create_leaderId(FsmCbOptions& options);

  name_ptr create_name(FsmCbOptions& options);

  departments_ptr create_departments(FsmCbOptions& options);

  allEmployees_ptr create_allEmployees(FsmCbOptions& options);

  attr_id_ptr create_attr_id(FsmCbOptions& options);
  

public:

  //types which this class needs, as INNER CLASSES
  
  //types which this class needs, as INNER CLASSES : END



}; //end class organization

  //
  // Following types(mostly typedefs) are the ones, based on above C++ class definition
  // for the top-level element {}organization
  //


  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;organization &gt; organization_ptr;
  /// typedef for the Plain pointer to the node
  typedef organization* organization_p;
  
} // end namespace org
#endif
</pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_Document.h">examples/org/include/org/Document.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_DOCUMENT_H__
#define  __org_DOCUMENT_H__
        
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"

#include "org/organization.h"
    

using namespace XPlus;
using namespace FSM;


namespace org {
    

class Document : public XMLSchema::TDocument
{
  private:
  
  
  organization_ptr _organization;
    
  AutoPtr&lt;XsdFSM&lt;organization_ptr&gt; &gt; _fsm_organization;
    
  
  // attributes, elements
  
  organization_ptr create_organization(FsmCbOptions& options);
  

  public:

  Document(bool buildTree=true, bool createSample=false);
  virtual ~Document() {}
    
  
  organization_p element_organization();
    
    
  void initFSM();
};

} // end namespace org
#endif
  </pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_all-include.h">examples/org/include/org/all-include.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_ALL_INCLUDE_H__
#define  __org_ALL_INCLUDE_H__

#include "XPlus/AutoPtr.h"

  
#include "org_engg/all-include.h"
  
#include "org_legal/all-include.h"
  
#include "org_hr/all-include.h"
  
#include "org/Document.h"

#include "org/organization.h"    
  
#include "org/Types/Departments.h"    
  

using namespace XPlus;


#endif 
  </pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_Types_Departments.h">examples/org/include/org/Types/Departments.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_types_Departments_H__
#define  __org_types_Departments_H__
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"


#include "org_engg/Types/EnggDept.h"
      
#include "org_legal/Types/LegalDept.h"
      
using namespace XPlus; 



namespace org {
    
namespace Types 
{
  
/// The class for complexType Departments
/// \n Refer to documentation on structures/methods inside ...
class Departments : public XMLSchema::Types::anyType
{
  public:
  //constructor
  Departments(AnyTypeCreateArgs args);

  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;org::engg::Types::EnggDept&gt; &gt; engineering_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;org::engg::Types::EnggDept&gt;* engineering_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;org::engg::Types::EnggDept&gt; engineering; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;org::legal::Types::LegalDept&gt; &gt; legal_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;org::legal::Types::LegalDept&gt;* legal_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;org::legal::Types::LegalDept&gt; legal; 
  
  /// The MG class inside a complexType
  /// \n Refer to documentation on structures/methods inside ...
  struct sequence : public XsdSequenceFsmOfFSMs 
  {
      

    /// constructor for the MG node
    sequence(Departments* that);

    

    ///  For the scalar-element with QName "{urn:org:engg}engineering" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    engineering_p element_engineering();

        

    ///  For the scalar-element with QName "{urn:org:legal}legal" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    legal_p element_legal();

        

    //  accessors for MGs/MGDs which are nested children of this MG/MGD
    

  private:  

    inline XsdFsmBase* clone() const {
      return new sequence(*this);
    }

    Departments*      _that;
  }; // end sequence
  

  ///  For the scalar-element with QName "{urn:org:engg}engineering" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  engineering_p element_engineering();
      

  ///  For the scalar-element with QName "{urn:org:legal}legal" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  legal_p element_legal();
      

  /// Returns the MG node(or node-list) inside  the complexType 
  sequence*  get_sequence() {
    return _sequence;
  }

    

  protected:
  
  XsdAllFsmOfFSMsPtr   _fsmAttrs;   
  XsdFsmBasePtr        _fsmElems;   
  
  
  AutoPtr&lt;sequence&gt; _sequence;
    
    
  engineering_ptr _engineering;
            
  legal_ptr _legal;
              

  /// initialize the FSM
  void initFSM();

  
  engineering_ptr create_engineering(FsmCbOptions& options);

  legal_ptr create_legal(FsmCbOptions& options);
  

public:

  //types which this class needs, as INNER CLASSES
  
  //types which this class needs, as INNER CLASSES : END

  

  private:
  static XSD::TypeDefinitionFactoryTmpl&lt;XmlElement&lt;Departments&gt; &gt;   s_typeRegistry;
}; //end class Departments
} // end namespace Types


} // end namespace org
#endif
  </pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_legal_all-include.h">examples/org/include/org_legal/all-include.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_legal_ALL_INCLUDE_H__
#define  __org_legal_ALL_INCLUDE_H__

#include "XPlus/AutoPtr.h"

  
#include "org_hr/all-include.h"
  
#include "org_legal/Types/LegalDept.h"    
  

using namespace XPlus;


#endif 
  </pre>
</div>
<br><br>
<h3><a name="examples_org_include_org_legal_Types_LegalDept.h">examples/org/include/org_legal/Types/LegalDept.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __org_legal_types_LegalDept_H__
#define  __org_legal_types_LegalDept_H__
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"


#include "org_hr/leaderId.h"
      
#include "org_hr/Types/UserIdList.h"
      
using namespace XPlus; 



namespace org {
      
namespace legal {
    
namespace Types 
{
  
/// The class for complexType LegalDept
/// \n Refer to documentation on structures/methods inside ...
class LegalDept : public XMLSchema::Types::anyType
{
  public:
  //constructor
  LegalDept(AnyTypeCreateArgs args);

  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;org::hr::leaderId &gt; leaderId_ptr;
  /// typedef for the Plain pointer to the node
  typedef org::hr::leaderId* leaderId_p;
  
  /// typedef for the node
  typedef org::hr::leaderId leaderId; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;org::hr::Types::UserIdList&gt; &gt; legalAdvisors_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::UserIdList&gt;* legalAdvisors_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;org::hr::Types::UserIdList&gt; legalAdvisors; 
  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlAttribute&lt;XMLSchema::Types::bt_token&gt; &gt; attr_id_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlAttribute&lt;XMLSchema::Types::bt_token&gt;* attr_id_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlAttribute&lt;XMLSchema::Types::bt_token&gt; attr_id; 
  
  /// The MG class inside a complexType
  /// \n Refer to documentation on structures/methods inside ...
  struct sequence : public XsdSequenceFsmOfFSMs 
  {
      

    /// constructor for the MG node
    sequence(LegalDept* that);

    

    ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    leaderId_p element_leaderId();

        

    ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
    ///  \n Sets the value of the scalar element with the supplied value.
    ///  @param val the value(as DOMString) to set with 
    void set_leaderId(DOMString val);

    ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
    ///  \n Returns the value of the scalar element 
    ///  @return the value(as DOMString) of the element 
    DOMString get_leaderId_string();

          

    ///  For the scalar-element with QName "{urn:org:hr}legalAdvisors" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    legalAdvisors_p element_legalAdvisors();

        

    //  accessors for MGs/MGDs which are nested children of this MG/MGD
    

  private:  

    inline XsdFsmBase* clone() const {
      return new sequence(*this);
    }

    LegalDept*      _that;
  }; // end sequence
  

  ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  leaderId_p element_leaderId();
      

  ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
  ///  \n Sets the value of the element with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_leaderId(DOMString val);
  
  ///  For the scalar-element with QName "{urn:org:hr}leaderId" :
  ///  \n Returns the value(as DOMString) of the element
  DOMString get_leaderId_string();

        

  ///  For the scalar-element with QName "{urn:org:hr}legalAdvisors" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  legalAdvisors_p element_legalAdvisors();
      

  ///  For the scalar-attribute with QName "{http://www.w3.org/2001/XMLSchema}id" :
  ///  \n Returns the scalar attribute node
  ///  @return the attribute node fetched
  attr_id_p attribute_attr_id();
      

  ///  For the scalar-attribute with QName "{http://www.w3.org/2001/XMLSchema}id" :
  ///  \n Sets the value of the attribute with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_attr_id(DOMString val);
  
  ///  For the scalar-attribute with QName "{http://www.w3.org/2001/XMLSchema}id" :
  ///  \n Returns the value(as DOMString) of the attribute
  DOMString get_attr_id_string();

        

  /// Returns the MG node(or node-list) inside  the complexType 
  sequence*  get_sequence() {
    return _sequence;
  }

    

  protected:
  
  XsdAllFsmOfFSMsPtr   _fsmAttrs;   
  XsdFsmBasePtr        _fsmElems;   
  
  
  AutoPtr&lt;sequence&gt; _sequence;
    
    
  leaderId_ptr _leaderId;
            
  legalAdvisors_ptr _legalAdvisors;
            
  attr_id_ptr _attr_id;
          

  /// initialize the FSM
  void initFSM();

  
  leaderId_ptr create_leaderId(FsmCbOptions& options);

  legalAdvisors_ptr create_legalAdvisors(FsmCbOptions& options);

  attr_id_ptr create_attr_id(FsmCbOptions& options);
  

public:

  //types which this class needs, as INNER CLASSES
  
  //types which this class needs, as INNER CLASSES : END

  

  private:
  static XSD::TypeDefinitionFactoryTmpl&lt;XmlElement&lt;LegalDept&gt; &gt;   s_typeRegistry;
}; //end class LegalDept
} // end namespace Types


} // end namespace legal  
} // end namespace org
#endif
  </pre>
</div>
<br><br>
<h3><a name="examples_org_main.cpp">examples/org/main.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  On subsequent "xsd2cpp" invocations, this file would not be overwritten.
 //  You can edit this file.
 //
  
#include &lt;iostream&gt;
#include &lt;string&gt;

#include "XSD/UserOps.h"
#include "org/all-include.h"

void populateDocument(org::Document* xsdDoc);
void updateOrConsumeDocument(org::Document* xsdDoc);
    

int main (int argc, char**argv)
{
  XSD::UserOps&lt;org::Document&gt;::UserOpsCbStruct cbStruct;
  cbStruct.cbPopulateDocument           =  populateDocument;
  cbStruct.cbUpdateOrConsumeDocument    =  updateOrConsumeDocument;
  

  XSD::UserOps&lt;org::Document&gt; opHandle(cbStruct);
  opHandle.run(argc, argv);
}

//
// Following functions are use case templates.
// You need to put "code" in the respective contexts.
//

    

// template function to populate the Tree with values
// write code to populate the Document here ...
void populateDocument(org::Document* xsdDoc)
{
  /*
  Jim Barnette    : org head

  Engg:  
      Paul V. Biron : engg head
   
    Project1: 
        Allen Brown : proj1 head
        Charles E. Campbell
        Wayne Carr

    Project2:
        Lee Buck : proj2 head
        Peter Chen
        David Cleary

  
  Legal:
      Don Box :legal head
      Dan Connolly
      Ugo Corda

  */

  org::organization* pOrgn = xsdDoc-&gt;element_organization();
  pOrgn-&gt;set_leaderId("jimb");
  pOrgn-&gt;set_attr_id("nasa");
  pOrgn-&gt;set_name("NASA");

  // all employees
  pOrgn-&gt;element_allEmployees()-&gt;set_count_employee(11);
  org::hr::Types::Employee* pEmpl = NULL;
  
  pEmpl = pOrgn-&gt;element_allEmployees()-&gt;element_employee_at(0);
  pEmpl-&gt;set_name("Jim Barnette");
  pEmpl-&gt;set_userId("jimb");
  pEmpl-&gt;set_joiningDate("1978-02-11");
  pEmpl-&gt;set_title("org head");
  pEmpl-&gt;element_reportees()-&gt;add_userId_string("paulb");
  pEmpl-&gt;element_reportees()-&gt;add_userId_string("donb");
  
  pEmpl = pOrgn-&gt;element_allEmployees()-&gt;element_employee_at(1);
  pEmpl-&gt;set_name("Paul V. Biron");
  pEmpl-&gt;set_userId("paulb");
  pEmpl-&gt;set_joiningDate("1978-02-15");
  pEmpl-&gt;set_title("Engg head");
  pEmpl-&gt;element_reportees()-&gt;add_userId_string("allenb");
  pEmpl-&gt;element_reportees()-&gt;add_userId_string("leeb");
  pEmpl-&gt;set_reportsTo("jimb");
  
  pEmpl = pOrgn-&gt;element_allEmployees()-&gt;element_employee_at(2);
  pEmpl-&gt;set_name("Don Box");
  pEmpl-&gt;set_userId("donb");
  pEmpl-&gt;set_joiningDate("1978-02-15");
  pEmpl-&gt;set_title("Legal head");
  pEmpl-&gt;element_reportees()-&gt;add_userId_string("danc");
  pEmpl-&gt;element_reportees()-&gt;add_userId_string("ugoc");
  pEmpl-&gt;set_reportsTo("jimb");
  
  pEmpl = pOrgn-&gt;element_allEmployees()-&gt;element_employee_at(3);
  pEmpl-&gt;set_name("Allen Brown");
  pEmpl-&gt;set_userId("allenb");
  pEmpl-&gt;set_joiningDate("1978-02-15");
  pEmpl-&gt;set_title("Proj1 head");
  pEmpl-&gt;element_reportees()-&gt;add_userId_string("charlese");
  pEmpl-&gt;element_reportees()-&gt;add_userId_string("waynec");
  pEmpl-&gt;set_reportsTo("paulb");
  
  pEmpl = pOrgn-&gt;element_allEmployees()-&gt;element_employee_at(4);
  pEmpl-&gt;set_name("Lee Buck");
  pEmpl-&gt;set_userId("leeb");
  pEmpl-&gt;set_joiningDate("1978-02-15");
  pEmpl-&gt;set_title("Proj2 head");
  pEmpl-&gt;element_reportees()-&gt;add_userId_string("peterc");
  pEmpl-&gt;element_reportees()-&gt;add_userId_string("davidc");
  pEmpl-&gt;set_reportsTo("paulb");
  
  pEmpl = pOrgn-&gt;element_allEmployees()-&gt;element_employee_at(5);
  pEmpl-&gt;set_name("Charles E Campbell");
  pEmpl-&gt;set_userId("charlese");
  pEmpl-&gt;set_joiningDate("1978-02-15");
  pEmpl-&gt;set_title("SMTS");
  pEmpl-&gt;set_reportsTo("allenb");

  pEmpl = pOrgn-&gt;element_allEmployees()-&gt;element_employee_at(6);
  pEmpl-&gt;set_name("Wayne Carr");
  pEmpl-&gt;set_userId("waynec");
  pEmpl-&gt;set_joiningDate("1978-02-15");
  pEmpl-&gt;set_title("SMTS");
  pEmpl-&gt;set_reportsTo("allenb");
  
  pEmpl = pOrgn-&gt;element_allEmployees()-&gt;element_employee_at(7);
  pEmpl-&gt;set_name("Peter Chen");
  pEmpl-&gt;set_userId("peterc");
  pEmpl-&gt;set_joiningDate("1978-02-15");
  pEmpl-&gt;set_title("SMTS");
  pEmpl-&gt;set_reportsTo("leeb");
  
  pEmpl = pOrgn-&gt;element_allEmployees()-&gt;element_employee_at(8);
  pEmpl-&gt;set_name("David Cleary");
  pEmpl-&gt;set_userId("davidc");
  pEmpl-&gt;set_joiningDate("1978-02-15");
  pEmpl-&gt;set_title("SMTS");
  pEmpl-&gt;set_reportsTo("leeb");

  pEmpl = pOrgn-&gt;element_allEmployees()-&gt;element_employee_at(9);
  pEmpl-&gt;set_name("Dan Connolly");
  pEmpl-&gt;set_userId("danc");
  pEmpl-&gt;set_joiningDate("1978-02-15");
  pEmpl-&gt;set_title("Legal Advisor");
  pEmpl-&gt;set_reportsTo("donb");
  
  pEmpl = pOrgn-&gt;element_allEmployees()-&gt;element_employee_at(10);
  pEmpl-&gt;set_name("Ugo Corda");
  pEmpl-&gt;set_userId("ugoc");
  pEmpl-&gt;set_joiningDate("1978-02-15");
  pEmpl-&gt;set_title("Legal Advisor");
  pEmpl-&gt;set_reportsTo("donb");
  

  org::Types::Departments::engineering* pEnggDept = pOrgn-&gt;element_departments()-&gt;element_engineering();
  pEnggDept-&gt;set_attr_id("nasa.deperatments.engineering");
  pEnggDept-&gt;set_leaderId("paulb");
  pEnggDept-&gt;set_count_project(2);

  org::engg::Types::EnggDept::project* pProj = NULL;
  
  pProj = pEnggDept-&gt;element_project_at(0);
  pProj-&gt;set_leaderId("allenb");
  pProj-&gt;element_engineers()-&gt;add_userId_string("charlese");
  pProj-&gt;element_engineers()-&gt;add_userId_string("waynec");
  pProj-&gt;set_projectName("The unmanned moon mission 2015");

  pProj = pEnggDept-&gt;element_project_at(1);
  pProj-&gt;set_leaderId("leeb");
  pProj-&gt;element_engineers()-&gt;add_userId_string("peterc");
  pProj-&gt;element_engineers()-&gt;add_userId_string("davidc");
  pProj-&gt;set_projectName("The manned moon mission 2020");

  org::Types::Departments::legal* pLegalDept = pOrgn-&gt;element_departments()-&gt;element_legal();
  pLegalDept-&gt;set_attr_id("nasa.deperatments.legal");
  pLegalDept-&gt;set_leaderId("donb");
  pLegalDept-&gt;element_legalAdvisors()-&gt;add_userId_string("danc");
  pLegalDept-&gt;element_legalAdvisors()-&gt;add_userId_string("ugoc");
}

// write code to operate(update/consume/test etc.) on the Document here...
// This Document is typically already populated(eg. read from an input
// xml file)
void updateOrConsumeDocument(org::Document* xsdDoc)
{

}

  
</pre>
</div>
<br><br>
<h3><a name="examples_org_src_org_hr_Document.cpp">examples/org/src/org_hr/Document.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "org_hr/Document.h"


namespace org {
      
namespace hr {
    

  ///constructor for the Document node
  Document::Document(bool buildTree_, bool createSample_):
    XMLSchema::TDocument(buildTree_, createSample_)
  {
    initFSM();
    DOM::Document::attributeDefaultQualified(false);
    DOM::Document::elementDefaultQualified(false);
    
  }

  void Document::initFSM()
  {
  
    _fsm_userId = new XsdFSM&lt;userId_ptr&gt;( Particle(new DOMString("urn:org:hr"),  DOMString("userId"), 1, 1),  XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;userId_ptr, Document, FsmCbOptions&gt;(this, &Document::create_userId));
  
    _fsm_leaderId = new XsdFSM&lt;leaderId_ptr&gt;( Particle(new DOMString("urn:org:hr"),  DOMString("leaderId"), 1, 1),  XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;leaderId_ptr, Document, FsmCbOptions&gt;(this, &Document::create_leaderId));
  
    XsdFsmBasePtr elemFsms[] = {
    _fsm_userId,
    _fsm_leaderId,
      
      NULL
    };
    XsdFsmBasePtr fofElem = new XsdFsmOfFSMs(elemFsms, XsdFsmOfFSMs::CHOICE);
    
    XsdFsmBasePtr docEndFsm = new XsdFSM&lt;void *&gt;(Particle(NULL, "", 1, 1), XsdEvent::DOCUMENT_END);
    XsdFsmBasePtr ptrFsms[] = { fofElem,  docEndFsm, NULL };
    _fsm = new XsdFsmOfFSMs(ptrFsms, XsdFsmOfFSMs::SEQUENCE);
  }

  
    void Document::set_root_userId() 
    {
    
      if(!_userId) {
        XsdEvent event(new DOMString("urn:org:hr"), NULL, DOMString("userId"), XsdEvent::ELEMENT_START);
        _fsm-&gt;processEventThrow(event); 
      }
    }
    
    void Document::set_root_leaderId() 
    {
    
      if(!_leaderId) {
        XsdEvent event(new DOMString("urn:org:hr"), NULL, DOMString("leaderId"), XsdEvent::ELEMENT_START);
        _fsm-&gt;processEventThrow(event); 
      }
    }
    


  /* element functions  */
  

  userId_ptr Document::create_userId(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("userId");
    static DOMStringPtr myNsUri = new DOMString("urn:org:hr");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this, this, _fsm, options, false, false, false, "urn:org:hr", "UserId");
    userId_p node = XSD::createElementTmpl&lt;userId, org::hr::Types::UserId*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _userId = node;
      
    return node;
  }

  
  userId_p Document::element_userId()
  {
    FSM::warnNullNode(_userId, "userId", "{urn:org:hr}userId", 1);
    return _userId;
  }
    

  leaderId_ptr Document::create_leaderId(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("leaderId");
    static DOMStringPtr myNsUri = new DOMString("urn:org:hr");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this, this, _fsm, options, false, false, false, "urn:org:hr", "UserId");
    leaderId_p node = XSD::createElementTmpl&lt;leaderId, org::hr::Types::UserId*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _leaderId = node;
      
    return node;
  }

  
  leaderId_p Document::element_leaderId()
  {
    FSM::warnNullNode(_leaderId, "leaderId", "{urn:org:hr}leaderId", 1);
    return _leaderId;
  }
    
} // end namespace hr  
} // end namespace org</pre>
</div>
<br><br>
<h3><a name="examples_org_src_org_hr_Types_AllEmployees.cpp">examples/org/src/org_hr/Types/AllEmployees.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "org_hr/Types/AllEmployees.h"

namespace org {
      
namespace hr {
    
namespace Types
{
  XSD::TypeDefinitionFactoryTmpl&lt;XmlElement&lt;AllEmployees&gt; &gt; AllEmployees::s_typeRegistry("AllEmployees", "urn:org:hr");

  

  //constructor
  
  AllEmployees::AllEmployees(AnyTypeCreateArgs args):
  XMLSchema::Types::anyType(AnyTypeCreateArgs(false, 
                                              args.ownerNode, 
                                              args.ownerElem, 
                                              args.ownerDoc, 
                                              args.childBuildsTree, 
                                              (args.createFromElementAttr? false : args.abstract),
                                              args.blockMask,
                                              args.finalMask,
                                              args.contentTypeVariety,
                                              args.anyTypeUseCase,
                                              args.suppressTypeAbstract
                                             )),
    
    _fsmElems(NULL),
    _fsmAttrs(NULL)
  
    , _sequence(new sequence(this) )
  
  {
    this-&gt;contentTypeVariety(CONTENT_TYPE_VARIETY_ELEMENT_ONLY);
    initFSM();
    if(args.ownerDoc && args.ownerDoc-&gt;buildTree() && !args.childBuildsTree)
    {
      if(args.ownerDoc-&gt;createSample()) {
        _fsm-&gt;fireSampleEvents();
      }
      else {
        _fsm-&gt;fireRequiredEvents();
      }
    }
  }
    
  void AllEmployees::initFSM()
  {
    XsdFsmBasePtr fsmsAttrs[] = {
  
      NULL
    };

    _fsm-&gt;replaceOrAppendUniqueAttributeFsms(fsmsAttrs);
  
    _fsm-&gt;replaceContentFsm(_sequence);
      
    _fsmAttrs = _fsm-&gt;attributeFsm();
    _fsmElems = _fsm-&gt;contentFsm();

  }

  /* element functions  */
  

  AllEmployees::employee_ptr AllEmployees::create_employee(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("employee");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "urn:org:hr", "Employee");
    AllEmployees::employee_p node = XSD::createElementTmpl&lt;employee, org::hr::Types::Employee*&gt;(t);
          
    _list_employee.push_back(node);
      
    return node;
  }

  
  AllEmployees::employee_p AllEmployees::element_employee_at(unsigned int idx)
  {
    if(idx &gt; _list_employee.size()-1) {
      throw IndexOutOfBoundsException("IndexOutOfBoundsException");
    }

    return _list_employee.at(idx);
  }
    
  List&lt;AllEmployees::employee_ptr&gt; AllEmployees::elements_employee()
  {
    return _list_employee;
  }
    
  AllEmployees::employee_p AllEmployees::add_node_employee()
  {
    return get_sequence()-&gt;add_node_employee();
  }

  List&lt;AllEmployees::employee_ptr&gt; AllEmployees::set_count_employee(unsigned int size)
  {
    return get_sequence()-&gt;set_count_employee(size);
  }

          

  /* attribute  functions  */
  
  //constructor
  AllEmployees::sequence::sequence(AllEmployees* that):
    _that(that)
  {
    XsdFsmBasePtr fsmArray[] = {
    new XsdFSM&lt;employee_ptr&gt;( Particle(NULL, DOMString("employee"), 1, -1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;employee_ptr, AllEmployees, FsmCbOptions&gt;(_that, &AllEmployees::create_employee)),
             
      NULL 
    } ;
    
    XsdSequenceFsmOfFSMs::init(fsmArray);
  }

      

  List&lt;AllEmployees::employee_ptr&gt; AllEmployees::sequence::elements_employee()
  {
      
    List&lt;employee_ptr&gt; nodeList;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[0].get();
    if(fsm_p) 
    {
      XsdFSM&lt;employee_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;employee_ptr&gt; *&gt;(fsm_p);
      if(unitFsm) {
        //nodeList = unitFsm-&gt;nodeList().stl_list(); 
        nodeList = unitFsm-&gt;nodeList(); 
      }
    }
    return nodeList;
        
  }
  
  
  AllEmployees::employee_p AllEmployees::sequence::element_employee_at(unsigned int idx)
  {
    return elements_employee().at(idx);
  }

    
  AllEmployees::employee_p AllEmployees::sequence::add_node_employee()
  {
    DOMStringPtr nsUriPtr = NULL;
    XsdEvent event(nsUriPtr, NULL, DOMString("employee"), XsdEvent::ELEMENT_START, false);
    this-&gt;processEventThrow(event); 
    return elements_employee().back();
  }

  List&lt;AllEmployees::employee_ptr&gt; AllEmployees::sequence::set_count_employee(unsigned int size)
  {
    if( (size &gt; -1) || (size &lt; 1)) {
      ostringstream oss;
      oss &lt;&lt; "set_count_employee: size should be in range: [" &lt;&lt; 1
        &lt;&lt; "," &lt;&lt; "unbounded" &lt;&lt; "]";
      throw IndexOutOfBoundsException(oss.str());
    }

    unsigned int prevSize = elements_employee().size();
    if(size &lt; prevSize) {
      //FIXME: allow later:
      throw XPlus::RuntimeException("resize lesser than current size not allowed");
    }

    for(unsigned int j=prevSize; j&lt;size; j++) 
    {
      // pretend docBuilding to avoid computation of adding after first loop
      XsdEvent event(NULL, NULL, DOMString("employee"), XsdEvent::ELEMENT_START, false);
      this-&gt;processEventThrow(event); 
    }
    
    return elements_employee();
  }

        
} //  end namespace Types 


} // end namespace hr  
} // end namespace org</pre>
</div>
<br><br>
<h3><a name="examples_org_src_org_hr_Types_UserIdList.cpp">examples/org/src/org_hr/Types/UserIdList.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "org_hr/Types/UserIdList.h"

namespace org {
      
namespace hr {
    
namespace Types
{
  XSD::TypeDefinitionFactoryTmpl&lt;XmlElement&lt;UserIdList&gt; &gt; UserIdList::s_typeRegistry("UserIdList", "urn:org:hr");

  

  //constructor
  
  UserIdList::UserIdList(AnyTypeCreateArgs args):
  XMLSchema::Types::anyType(AnyTypeCreateArgs(false, 
                                              args.ownerNode, 
                                              args.ownerElem, 
                                              args.ownerDoc, 
                                              args.childBuildsTree, 
                                              (args.createFromElementAttr? false : args.abstract),
                                              args.blockMask,
                                              args.finalMask,
                                              args.contentTypeVariety,
                                              args.anyTypeUseCase,
                                              args.suppressTypeAbstract
                                             )),
    
    _fsmElems(NULL),
    _fsmAttrs(NULL)
  
    , _sequence(new sequence(this) )
  
  {
    this-&gt;contentTypeVariety(CONTENT_TYPE_VARIETY_ELEMENT_ONLY);
    initFSM();
    if(args.ownerDoc && args.ownerDoc-&gt;buildTree() && !args.childBuildsTree)
    {
      if(args.ownerDoc-&gt;createSample()) {
        _fsm-&gt;fireSampleEvents();
      }
      else {
        _fsm-&gt;fireRequiredEvents();
      }
    }
  }
    
  void UserIdList::initFSM()
  {
    XsdFsmBasePtr fsmsAttrs[] = {
  
      NULL
    };

    _fsm-&gt;replaceOrAppendUniqueAttributeFsms(fsmsAttrs);
  
    _fsm-&gt;replaceContentFsm(_sequence);
      
    _fsmAttrs = _fsm-&gt;attributeFsm();
    _fsmElems = _fsm-&gt;contentFsm();

  }

  /* element functions  */
  

  userId_ptr UserIdList::create_userId(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("userId");
    static DOMStringPtr myNsUri = new DOMString("urn:org:hr");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false);
    userId_p node = XSD::createElementTmpl&lt;userId, void*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _list_userId.push_back(node);
      
    return node;
  }

  
  userId_p UserIdList::element_userId_at(unsigned int idx)
  {
    if(idx &gt; _list_userId.size()-1) {
      throw IndexOutOfBoundsException("IndexOutOfBoundsException");
    }

    return _list_userId.at(idx);
  }
    
  List&lt;userId_ptr&gt; UserIdList::elements_userId()
  {
    return _list_userId;
  }
    
  userId_p UserIdList::add_node_userId()
  {
    return get_sequence()-&gt;add_node_userId();
  }

  List&lt;userId_ptr&gt; UserIdList::set_count_userId(unsigned int size)
  {
    return get_sequence()-&gt;set_count_userId(size);
  }

        
      
    void UserIdList::add_userId_string(DOMString val)
    {
      get_sequence()-&gt;add_userId_string(val);
    }

          
  void UserIdList::set_userId(unsigned int idx, DOMString val)
  {
    get_sequence()-&gt;set_userId(idx, val);
  }

  DOMString UserIdList::get_userId_string(unsigned int idx)
  {
    return get_sequence()-&gt;get_userId_string(idx);
  }

            

  /* attribute  functions  */
  
  //constructor
  UserIdList::sequence::sequence(UserIdList* that):
    _that(that)
  {
    XsdFsmBasePtr fsmArray[] = {
    new XsdFSM&lt;userId_ptr&gt;( Particle(new DOMString("urn:org:hr"), DOMString("userId"), 0, -1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;userId_ptr, UserIdList, FsmCbOptions&gt;(_that, &UserIdList::create_userId)),
             
      NULL 
    } ;
    
    XsdSequenceFsmOfFSMs::init(fsmArray);
  }

      

  List&lt;userId_ptr&gt; UserIdList::sequence::elements_userId()
  {
      
    List&lt;userId_ptr&gt; nodeList;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[0].get();
    if(fsm_p) 
    {
      XsdFSM&lt;userId_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;userId_ptr&gt; *&gt;(fsm_p);
      if(unitFsm) {
        //nodeList = unitFsm-&gt;nodeList().stl_list(); 
        nodeList = unitFsm-&gt;nodeList(); 
      }
    }
    return nodeList;
        
  }
  
  
  userId_p UserIdList::sequence::element_userId_at(unsigned int idx)
  {
    return elements_userId().at(idx);
  }

    
  void UserIdList::sequence::set_userId(unsigned int idx, DOMString val)
  {
    element_userId_at(idx)-&gt;stringValue(val);
  }

  DOMString UserIdList::sequence::get_userId_string(unsigned int idx)
  {
    return element_userId_at(idx)-&gt;stringValue();
  }
      
  userId_p UserIdList::sequence::add_node_userId()
  {
    DOMStringPtr nsUriPtr = new DOMString("urn:org:hr");
    XsdEvent event(nsUriPtr, NULL, DOMString("userId"), XsdEvent::ELEMENT_START, false);
    this-&gt;processEventThrow(event); 
    return elements_userId().back();
  }

  List&lt;userId_ptr&gt; UserIdList::sequence::set_count_userId(unsigned int size)
  {
    if( (size &gt; -1) || (size &lt; 0)) {
      ostringstream oss;
      oss &lt;&lt; "set_count_userId: size should be in range: [" &lt;&lt; 0
        &lt;&lt; "," &lt;&lt; "unbounded" &lt;&lt; "]";
      throw IndexOutOfBoundsException(oss.str());
    }

    unsigned int prevSize = elements_userId().size();
    if(size &lt; prevSize) {
      //FIXME: allow later:
      throw XPlus::RuntimeException("resize lesser than current size not allowed");
    }

    for(unsigned int j=prevSize; j&lt;size; j++) 
    {
      // pretend docBuilding to avoid computation of adding after first loop
      XsdEvent event(new DOMString("urn:org:hr"), NULL, DOMString("userId"), XsdEvent::ELEMENT_START, false);
      this-&gt;processEventThrow(event); 
    }
    
    return elements_userId();
  }

        
    
  void UserIdList::sequence::add_userId_string(DOMString val)
  {
    this-&gt;add_node_userId()-&gt;stringValue(val);
  }
          
} //  end namespace Types 


} // end namespace hr  
} // end namespace org</pre>
</div>
<br><br>
<h3><a name="examples_org_src_org_hr_Types_Employee.cpp">examples/org/src/org_hr/Types/Employee.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "org_hr/Types/Employee.h"

namespace org {
      
namespace hr {
    
namespace Types
{
  XSD::TypeDefinitionFactoryTmpl&lt;XmlElement&lt;Employee&gt; &gt; Employee::s_typeRegistry("Employee", "urn:org:hr");

  

  //constructor
  
  Employee::Employee(AnyTypeCreateArgs args):
  XMLSchema::Types::anyType(AnyTypeCreateArgs(false, 
                                              args.ownerNode, 
                                              args.ownerElem, 
                                              args.ownerDoc, 
                                              args.childBuildsTree, 
                                              (args.createFromElementAttr? false : args.abstract),
                                              args.blockMask,
                                              args.finalMask,
                                              args.contentTypeVariety,
                                              args.anyTypeUseCase,
                                              args.suppressTypeAbstract
                                             )),
    
    _fsmElems(NULL),
    _fsmAttrs(NULL)
  
    , _sequence(new sequence(this) )
  
  {
    this-&gt;contentTypeVariety(CONTENT_TYPE_VARIETY_ELEMENT_ONLY);
    initFSM();
    if(args.ownerDoc && args.ownerDoc-&gt;buildTree() && !args.childBuildsTree)
    {
      if(args.ownerDoc-&gt;createSample()) {
        _fsm-&gt;fireSampleEvents();
      }
      else {
        _fsm-&gt;fireRequiredEvents();
      }
    }
  }
    
  void Employee::initFSM()
  {
    XsdFsmBasePtr fsmsAttrs[] = {
  
      NULL
    };

    _fsm-&gt;replaceOrAppendUniqueAttributeFsms(fsmsAttrs);
  
    _fsm-&gt;replaceContentFsm(_sequence);
      
    _fsmAttrs = _fsm-&gt;attributeFsm();
    _fsmElems = _fsm-&gt;contentFsm();

  }

  /* element functions  */
  

  userId_ptr Employee::create_userId(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("userId");
    static DOMStringPtr myNsUri = new DOMString("urn:org:hr");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false);
    userId_p node = XSD::createElementTmpl&lt;userId, void*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _userId = node;
      
    return node;
  }

  
  userId_p Employee::element_userId()
  {
    FSM::warnNullNode(_userId, "userId", "{urn:org:hr}userId", 1);
    return _userId;
  }
    
  void Employee::set_userId(DOMString val)
  {
    get_sequence()-&gt;set_userId(val);
  }

  DOMString Employee::get_userId_string()
  {
    return get_sequence()-&gt;get_userId_string();
  }

          

  Employee::name_ptr Employee::create_name(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("name");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "http://www.w3.org/2001/XMLSchema", "string");
    Employee::name_p node = XSD::createElementTmpl&lt;name, XMLSchema::Types::bt_string*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _name = node;
      
    return node;
  }

  
  Employee::name_p Employee::element_name()
  {
    FSM::warnNullNode(_name, "name", "{http://www.w3.org/2001/XMLSchema}name", 1);
    return _name;
  }
    
  void Employee::set_name(DOMString val)
  {
    get_sequence()-&gt;set_name(val);
  }

  DOMString Employee::get_name_string()
  {
    return get_sequence()-&gt;get_name_string();
  }

          

  Employee::title_ptr Employee::create_title(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("title");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "http://www.w3.org/2001/XMLSchema", "string");
    Employee::title_p node = XSD::createElementTmpl&lt;title, XMLSchema::Types::bt_string*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _title = node;
      
    return node;
  }

  
  Employee::title_p Employee::element_title()
  {
    FSM::warnNullNode(_title, "title", "{http://www.w3.org/2001/XMLSchema}title", 1);
    return _title;
  }
    
  void Employee::set_title(DOMString val)
  {
    get_sequence()-&gt;set_title(val);
  }

  DOMString Employee::get_title_string()
  {
    return get_sequence()-&gt;get_title_string();
  }

          

  Employee::joiningDate_ptr Employee::create_joiningDate(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("joiningDate");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "http://www.w3.org/2001/XMLSchema", "date");
    Employee::joiningDate_p node = XSD::createElementTmpl&lt;joiningDate, XMLSchema::Types::bt_date*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _joiningDate = node;
      
    return node;
  }

  
  Employee::joiningDate_p Employee::element_joiningDate()
  {
    FSM::warnNullNode(_joiningDate, "joiningDate", "{http://www.w3.org/2001/XMLSchema}joiningDate", 1);
    return _joiningDate;
  }
    
  void Employee::set_joiningDate(DOMString val)
  {
    get_sequence()-&gt;set_joiningDate(val);
  }

  DOMString Employee::get_joiningDate_string()
  {
    return get_sequence()-&gt;get_joiningDate_string();
  }

          
  void Employee::set_joiningDate(XPlus::Date val)
  {
    get_sequence()-&gt;set_joiningDate(val);
  }
  
  XPlus::Date Employee::get_joiningDate()
  {
    return get_sequence()-&gt;get_joiningDate();
  }

          

  Employee::reportsTo_ptr Employee::create_reportsTo(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("reportsTo");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "urn:org:hr", "UserId");
    Employee::reportsTo_p node = XSD::createElementTmpl&lt;reportsTo, org::hr::Types::UserId*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _reportsTo = node;
      
    return node;
  }

  
  Employee::reportsTo_p Employee::element_reportsTo()
  {
    FSM::warnNullNode(_reportsTo, "reportsTo", "{urn:org:hr}reportsTo", 0);
    return _reportsTo;
  }
    
  void Employee::set_reportsTo(DOMString val)
  {
    get_sequence()-&gt;set_reportsTo(val);
  }

  DOMString Employee::get_reportsTo_string()
  {
    return get_sequence()-&gt;get_reportsTo_string();
  }

          
  void Employee::mark_present_reportsTo()
  {
    return get_sequence()-&gt;mark_present_reportsTo();
  }
      

  Employee::reportees_ptr Employee::create_reportees(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("reportees");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "urn:org:hr", "UserIdList");
    Employee::reportees_p node = XSD::createElementTmpl&lt;reportees, org::hr::Types::UserIdList*&gt;(t);
          
    _reportees = node;
      
    return node;
  }

  
  Employee::reportees_p Employee::element_reportees()
  {
    FSM::warnNullNode(_reportees, "reportees", "{urn:org:hr}reportees", 1);
    return _reportees;
  }
      

  /* attribute  functions  */
  
  //constructor
  Employee::sequence::sequence(Employee* that):
    _that(that)
  {
    XsdFsmBasePtr fsmArray[] = {
    new XsdFSM&lt;userId_ptr&gt;( Particle(new DOMString("urn:org:hr"), DOMString("userId"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;userId_ptr, Employee, FsmCbOptions&gt;(_that, &Employee::create_userId)),
      new XsdFSM&lt;name_ptr&gt;( Particle(NULL, DOMString("name"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;name_ptr, Employee, FsmCbOptions&gt;(_that, &Employee::create_name)),
      new XsdFSM&lt;title_ptr&gt;( Particle(NULL, DOMString("title"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;title_ptr, Employee, FsmCbOptions&gt;(_that, &Employee::create_title)),
      new XsdFSM&lt;joiningDate_ptr&gt;( Particle(NULL, DOMString("joiningDate"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;joiningDate_ptr, Employee, FsmCbOptions&gt;(_that, &Employee::create_joiningDate)),
      new XsdFSM&lt;reportsTo_ptr&gt;( Particle(NULL, DOMString("reportsTo"), 0, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;reportsTo_ptr, Employee, FsmCbOptions&gt;(_that, &Employee::create_reportsTo)),
      new XsdFSM&lt;reportees_ptr&gt;( Particle(NULL, DOMString("reportees"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;reportees_ptr, Employee, FsmCbOptions&gt;(_that, &Employee::create_reportees)),
             
      NULL 
    } ;
    
    XsdSequenceFsmOfFSMs::init(fsmArray);
  }

      

  userId_p Employee::sequence::element_userId()
  {
      userId_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[0].get();
    if(fsm_p) 
    {
      XsdFSM&lt;userId_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;userId_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "userId", "{urn:org:hr}userId", 1);
    return node_p;
        
  }
  
  
  void Employee::sequence::set_userId(DOMString val)
  {
      
    element_userId()-&gt;stringValue(val);
  }

  DOMString Employee::sequence::get_userId_string()
  {
    return element_userId()-&gt;stringValue();
  }

          

  Employee::name_p Employee::sequence::element_name()
  {
      Employee::name_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[1].get();
    if(fsm_p) 
    {
      XsdFSM&lt;name_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;name_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "name", "{http://www.w3.org/2001/XMLSchema}name", 1);
    return node_p;
        
  }
  
  
  void Employee::sequence::set_name(DOMString val)
  {
      
    element_name()-&gt;stringValue(val);
  }

  DOMString Employee::sequence::get_name_string()
  {
    return element_name()-&gt;stringValue();
  }

          

  Employee::title_p Employee::sequence::element_title()
  {
      Employee::title_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[2].get();
    if(fsm_p) 
    {
      XsdFSM&lt;title_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;title_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "title", "{http://www.w3.org/2001/XMLSchema}title", 1);
    return node_p;
        
  }
  
  
  void Employee::sequence::set_title(DOMString val)
  {
      
    element_title()-&gt;stringValue(val);
  }

  DOMString Employee::sequence::get_title_string()
  {
    return element_title()-&gt;stringValue();
  }

          

  Employee::joiningDate_p Employee::sequence::element_joiningDate()
  {
      Employee::joiningDate_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[3].get();
    if(fsm_p) 
    {
      XsdFSM&lt;joiningDate_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;joiningDate_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "joiningDate", "{http://www.w3.org/2001/XMLSchema}joiningDate", 1);
    return node_p;
        
  }
  
  
  void Employee::sequence::set_joiningDate(DOMString val)
  {
      
    element_joiningDate()-&gt;stringValue(val);
  }

  DOMString Employee::sequence::get_joiningDate_string()
  {
    return element_joiningDate()-&gt;stringValue();
  }

      
  void Employee::sequence::set_joiningDate(XPlus::Date val)     
  {
        
    element_joiningDate()-&gt;value(val);
  }

  XPlus::Date Employee::sequence::get_joiningDate()     
  {
    return element_joiningDate()-&gt;value();
  }

          

  Employee::reportsTo_p Employee::sequence::element_reportsTo()
  {
      Employee::reportsTo_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[4].get();
    if(fsm_p) 
    {
      XsdFSM&lt;reportsTo_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;reportsTo_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "reportsTo", "{urn:org:hr}reportsTo", 0);
    return node_p;
        
  }
  
  
  void Employee::sequence::set_reportsTo(DOMString val)
  {
      
    mark_present_reportsTo();
      
    element_reportsTo()-&gt;stringValue(val);
  }

  DOMString Employee::sequence::get_reportsTo_string()
  {
    return element_reportsTo()-&gt;stringValue();
  }

      

  void Employee::sequence::mark_present_reportsTo()
  {
    DOMStringPtr nsUriPtr = NULL;
    XsdEvent event(nsUriPtr, NULL, DOMString("reportsTo"), XsdEvent::ELEMENT_START, false);
    this-&gt;processEventThrow(event); 
  }

            

  Employee::reportees_p Employee::sequence::element_reportees()
  {
      Employee::reportees_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[5].get();
    if(fsm_p) 
    {
      XsdFSM&lt;reportees_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;reportees_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "reportees", "{urn:org:hr}reportees", 1);
    return node_p;
        
  }
  
  
} //  end namespace Types 


} // end namespace hr  
} // end namespace org</pre>
</div>
<br><br>
<h3><a name="examples_org_src_org_engg_Types_EnggDept.cpp">examples/org/src/org_engg/Types/EnggDept.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "org_engg/Types/EnggDept.h"

namespace org {
      
namespace engg {
    
namespace Types
{
  XSD::TypeDefinitionFactoryTmpl&lt;XmlElement&lt;EnggDept&gt; &gt; EnggDept::s_typeRegistry("EnggDept", "urn:org:engg");

  

  //constructor
  
  EnggDept::EnggDept(AnyTypeCreateArgs args):
  XMLSchema::Types::anyType(AnyTypeCreateArgs(false, 
                                              args.ownerNode, 
                                              args.ownerElem, 
                                              args.ownerDoc, 
                                              args.childBuildsTree, 
                                              (args.createFromElementAttr? false : args.abstract),
                                              args.blockMask,
                                              args.finalMask,
                                              args.contentTypeVariety,
                                              args.anyTypeUseCase,
                                              args.suppressTypeAbstract
                                             )),
    
    _fsmElems(NULL),
    _fsmAttrs(NULL)
  
    , _sequence(new sequence(this) )
  
  {
    this-&gt;contentTypeVariety(CONTENT_TYPE_VARIETY_ELEMENT_ONLY);
    initFSM();
    if(args.ownerDoc && args.ownerDoc-&gt;buildTree() && !args.childBuildsTree)
    {
      if(args.ownerDoc-&gt;createSample()) {
        _fsm-&gt;fireSampleEvents();
      }
      else {
        _fsm-&gt;fireRequiredEvents();
      }
    }
  }
    
  void EnggDept::initFSM()
  {
    XsdFsmBasePtr fsmsAttrs[] = {
  new XsdFSM&lt;attr_id_ptr&gt;( Particle(NULL, DOMString("id"), 1, 1), XsdEvent::ATTRIBUTE, new object_unary_mem_fun_t&lt;attr_id_ptr, EnggDept, FsmCbOptions&gt;(this, &EnggDept::create_attr_id)),
  
      NULL
    };

    _fsm-&gt;replaceOrAppendUniqueAttributeFsms(fsmsAttrs);
  
    _fsm-&gt;replaceContentFsm(_sequence);
      
    _fsmAttrs = _fsm-&gt;attributeFsm();
    _fsmElems = _fsm-&gt;contentFsm();

  }

  /* element functions  */
  

  org::hr::leaderId_ptr EnggDept::create_leaderId(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("leaderId");
    static DOMStringPtr myNsUri = new DOMString("urn:org:hr");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false);
    org::hr::leaderId_p node = XSD::createElementTmpl&lt;leaderId, void*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _leaderId = node;
      
    return node;
  }

  
  org::hr::leaderId_p EnggDept::element_leaderId()
  {
    FSM::warnNullNode(_leaderId, "leaderId", "{urn:org:hr}leaderId", 1);
    return _leaderId;
  }
    
  void EnggDept::set_leaderId(DOMString val)
  {
    get_sequence()-&gt;set_leaderId(val);
  }

  DOMString EnggDept::get_leaderId_string()
  {
    return get_sequence()-&gt;get_leaderId_string();
  }

          

  EnggDept::project_ptr EnggDept::create_project(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("project");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "urn:org:engg", "EnggProject");
    EnggDept::project_p node = XSD::createElementTmpl&lt;project, org::engg::Types::EnggProject*&gt;(t);
          
    _list_project.push_back(node);
      
    return node;
  }

  
  EnggDept::project_p EnggDept::element_project_at(unsigned int idx)
  {
    if(idx &gt; _list_project.size()-1) {
      throw IndexOutOfBoundsException("IndexOutOfBoundsException");
    }

    return _list_project.at(idx);
  }
    
  List&lt;EnggDept::project_ptr&gt; EnggDept::elements_project()
  {
    return _list_project;
  }
    
  EnggDept::project_p EnggDept::add_node_project()
  {
    return get_sequence()-&gt;add_node_project();
  }

  List&lt;EnggDept::project_ptr&gt; EnggDept::set_count_project(unsigned int size)
  {
    return get_sequence()-&gt;set_count_project(size);
  }

          

  /* attribute  functions  */
  

  EnggDept::attr_id_ptr EnggDept::create_attr_id(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("id");
    static DOMStringPtr myNsUri = NULL;
    
    if(_attr_id) {
      return _attr_id;
    }  
    XSD::StructCreateAttrThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options);
    EnggDept::attr_id_p node = XSD::createAttributeTmpl&lt;attr_id&gt;(t);
      
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _attr_id = node;
      
    return node;
  }

  
    void EnggDept::set_attr_id(DOMString val)
    {
        
      attribute_attr_id()-&gt;stringValue(val);
    }

    DOMString EnggDept::get_attr_id_string()
    {
       
      return attribute_attr_id()-&gt;stringValue();
    }

    
  EnggDept::attr_id_p EnggDept::attribute_attr_id()
  {
    FSM::warnNullNode(_attr_id, "attr_id", "{http://www.w3.org/2001/XMLSchema}id", 1);
    return _attr_id;
  }
    
  //constructor
  EnggDept::sequence::sequence(EnggDept* that):
    _that(that)
  {
    XsdFsmBasePtr fsmArray[] = {
    new XsdFSM&lt;leaderId_ptr&gt;( Particle(new DOMString("urn:org:hr"), DOMString("leaderId"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;leaderId_ptr, EnggDept, FsmCbOptions&gt;(_that, &EnggDept::create_leaderId)),
      new XsdFSM&lt;project_ptr&gt;( Particle(NULL, DOMString("project"), 1, -1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;project_ptr, EnggDept, FsmCbOptions&gt;(_that, &EnggDept::create_project)),
             
      NULL 
    } ;
    
    XsdSequenceFsmOfFSMs::init(fsmArray);
  }

      

  org::hr::leaderId_p EnggDept::sequence::element_leaderId()
  {
      org::hr::leaderId_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[0].get();
    if(fsm_p) 
    {
      XsdFSM&lt;leaderId_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;leaderId_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "leaderId", "{urn:org:hr}leaderId", 1);
    return node_p;
        
  }
  
  
  void EnggDept::sequence::set_leaderId(DOMString val)
  {
      
    element_leaderId()-&gt;stringValue(val);
  }

  DOMString EnggDept::sequence::get_leaderId_string()
  {
    return element_leaderId()-&gt;stringValue();
  }

          

  List&lt;EnggDept::project_ptr&gt; EnggDept::sequence::elements_project()
  {
      
    List&lt;project_ptr&gt; nodeList;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[1].get();
    if(fsm_p) 
    {
      XsdFSM&lt;project_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;project_ptr&gt; *&gt;(fsm_p);
      if(unitFsm) {
        //nodeList = unitFsm-&gt;nodeList().stl_list(); 
        nodeList = unitFsm-&gt;nodeList(); 
      }
    }
    return nodeList;
        
  }
  
  
  EnggDept::project_p EnggDept::sequence::element_project_at(unsigned int idx)
  {
    return elements_project().at(idx);
  }

    
  EnggDept::project_p EnggDept::sequence::add_node_project()
  {
    DOMStringPtr nsUriPtr = NULL;
    XsdEvent event(nsUriPtr, NULL, DOMString("project"), XsdEvent::ELEMENT_START, false);
    this-&gt;processEventThrow(event); 
    return elements_project().back();
  }

  List&lt;EnggDept::project_ptr&gt; EnggDept::sequence::set_count_project(unsigned int size)
  {
    if( (size &gt; -1) || (size &lt; 1)) {
      ostringstream oss;
      oss &lt;&lt; "set_count_project: size should be in range: [" &lt;&lt; 1
        &lt;&lt; "," &lt;&lt; "unbounded" &lt;&lt; "]";
      throw IndexOutOfBoundsException(oss.str());
    }

    unsigned int prevSize = elements_project().size();
    if(size &lt; prevSize) {
      //FIXME: allow later:
      throw XPlus::RuntimeException("resize lesser than current size not allowed");
    }

    for(unsigned int j=prevSize; j&lt;size; j++) 
    {
      // pretend docBuilding to avoid computation of adding after first loop
      XsdEvent event(NULL, NULL, DOMString("project"), XsdEvent::ELEMENT_START, false);
      this-&gt;processEventThrow(event); 
    }
    
    return elements_project();
  }

        
} //  end namespace Types 


} // end namespace engg  
} // end namespace org</pre>
</div>
<br><br>
<h3><a name="examples_org_src_org_engg_Types_EnggProject.cpp">examples/org/src/org_engg/Types/EnggProject.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "org_engg/Types/EnggProject.h"

namespace org {
      
namespace engg {
    
namespace Types
{
  XSD::TypeDefinitionFactoryTmpl&lt;XmlElement&lt;EnggProject&gt; &gt; EnggProject::s_typeRegistry("EnggProject", "urn:org:engg");

  

  //constructor
  
  EnggProject::EnggProject(AnyTypeCreateArgs args):
  XMLSchema::Types::anyType(AnyTypeCreateArgs(false, 
                                              args.ownerNode, 
                                              args.ownerElem, 
                                              args.ownerDoc, 
                                              args.childBuildsTree, 
                                              (args.createFromElementAttr? false : args.abstract),
                                              args.blockMask,
                                              args.finalMask,
                                              args.contentTypeVariety,
                                              args.anyTypeUseCase,
                                              args.suppressTypeAbstract
                                             )),
    
    _fsmElems(NULL),
    _fsmAttrs(NULL)
  
    , _sequence(new sequence(this) )
  
  {
    this-&gt;contentTypeVariety(CONTENT_TYPE_VARIETY_ELEMENT_ONLY);
    initFSM();
    if(args.ownerDoc && args.ownerDoc-&gt;buildTree() && !args.childBuildsTree)
    {
      if(args.ownerDoc-&gt;createSample()) {
        _fsm-&gt;fireSampleEvents();
      }
      else {
        _fsm-&gt;fireRequiredEvents();
      }
    }
  }
    
  void EnggProject::initFSM()
  {
    XsdFsmBasePtr fsmsAttrs[] = {
  
      NULL
    };

    _fsm-&gt;replaceOrAppendUniqueAttributeFsms(fsmsAttrs);
  
    _fsm-&gt;replaceContentFsm(_sequence);
      
    _fsmAttrs = _fsm-&gt;attributeFsm();
    _fsmElems = _fsm-&gt;contentFsm();

  }

  /* element functions  */
  

  org::hr::leaderId_ptr EnggProject::create_leaderId(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("leaderId");
    static DOMStringPtr myNsUri = new DOMString("urn:org:hr");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false);
    org::hr::leaderId_p node = XSD::createElementTmpl&lt;leaderId, void*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _leaderId = node;
      
    return node;
  }

  
  org::hr::leaderId_p EnggProject::element_leaderId()
  {
    FSM::warnNullNode(_leaderId, "leaderId", "{urn:org:hr}leaderId", 1);
    return _leaderId;
  }
    
  void EnggProject::set_leaderId(DOMString val)
  {
    get_sequence()-&gt;set_leaderId(val);
  }

  DOMString EnggProject::get_leaderId_string()
  {
    return get_sequence()-&gt;get_leaderId_string();
  }

          

  EnggProject::projectName_ptr EnggProject::create_projectName(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("projectName");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "http://www.w3.org/2001/XMLSchema", "string");
    EnggProject::projectName_p node = XSD::createElementTmpl&lt;projectName, XMLSchema::Types::bt_string*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _projectName = node;
      
    return node;
  }

  
  EnggProject::projectName_p EnggProject::element_projectName()
  {
    FSM::warnNullNode(_projectName, "projectName", "{http://www.w3.org/2001/XMLSchema}projectName", 1);
    return _projectName;
  }
    
  void EnggProject::set_projectName(DOMString val)
  {
    get_sequence()-&gt;set_projectName(val);
  }

  DOMString EnggProject::get_projectName_string()
  {
    return get_sequence()-&gt;get_projectName_string();
  }

          

  EnggProject::engineers_ptr EnggProject::create_engineers(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("engineers");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "urn:org:hr", "UserIdList");
    EnggProject::engineers_p node = XSD::createElementTmpl&lt;engineers, org::hr::Types::UserIdList*&gt;(t);
          
    _engineers = node;
      
    return node;
  }

  
  EnggProject::engineers_p EnggProject::element_engineers()
  {
    FSM::warnNullNode(_engineers, "engineers", "{urn:org:hr}engineers", 1);
    return _engineers;
  }
      

  /* attribute  functions  */
  
  //constructor
  EnggProject::sequence::sequence(EnggProject* that):
    _that(that)
  {
    XsdFsmBasePtr fsmArray[] = {
    new XsdFSM&lt;leaderId_ptr&gt;( Particle(new DOMString("urn:org:hr"), DOMString("leaderId"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;leaderId_ptr, EnggProject, FsmCbOptions&gt;(_that, &EnggProject::create_leaderId)),
      new XsdFSM&lt;projectName_ptr&gt;( Particle(NULL, DOMString("projectName"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;projectName_ptr, EnggProject, FsmCbOptions&gt;(_that, &EnggProject::create_projectName)),
      new XsdFSM&lt;engineers_ptr&gt;( Particle(NULL, DOMString("engineers"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;engineers_ptr, EnggProject, FsmCbOptions&gt;(_that, &EnggProject::create_engineers)),
             
      NULL 
    } ;
    
    XsdSequenceFsmOfFSMs::init(fsmArray);
  }

      

  org::hr::leaderId_p EnggProject::sequence::element_leaderId()
  {
      org::hr::leaderId_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[0].get();
    if(fsm_p) 
    {
      XsdFSM&lt;leaderId_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;leaderId_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "leaderId", "{urn:org:hr}leaderId", 1);
    return node_p;
        
  }
  
  
  void EnggProject::sequence::set_leaderId(DOMString val)
  {
      
    element_leaderId()-&gt;stringValue(val);
  }

  DOMString EnggProject::sequence::get_leaderId_string()
  {
    return element_leaderId()-&gt;stringValue();
  }

          

  EnggProject::projectName_p EnggProject::sequence::element_projectName()
  {
      EnggProject::projectName_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[1].get();
    if(fsm_p) 
    {
      XsdFSM&lt;projectName_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;projectName_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "projectName", "{http://www.w3.org/2001/XMLSchema}projectName", 1);
    return node_p;
        
  }
  
  
  void EnggProject::sequence::set_projectName(DOMString val)
  {
      
    element_projectName()-&gt;stringValue(val);
  }

  DOMString EnggProject::sequence::get_projectName_string()
  {
    return element_projectName()-&gt;stringValue();
  }

          

  EnggProject::engineers_p EnggProject::sequence::element_engineers()
  {
      EnggProject::engineers_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[2].get();
    if(fsm_p) 
    {
      XsdFSM&lt;engineers_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;engineers_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "engineers", "{urn:org:hr}engineers", 1);
    return node_p;
        
  }
  
  
} //  end namespace Types 


} // end namespace engg  
} // end namespace org</pre>
</div>
<br><br>
<h3><a name="examples_org_src_org_Document.cpp">examples/org/src/org/Document.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "org/Document.h"


namespace org {
    

  ///constructor for the Document node
  Document::Document(bool buildTree_, bool createSample_):
    XMLSchema::TDocument(buildTree_, createSample_)
  {
    initFSM();
    DOM::Document::attributeDefaultQualified(false);
    DOM::Document::elementDefaultQualified(false);
    
    if(buildTree()) 
    {
      
      DOMStringPtr nsUriPtr = new DOMString("urn:org");   
      XsdEvent event(nsUriPtr, NULL, DOMString("organization"), XsdEvent::ELEMENT_START);
      if(this-&gt;createSample()) {
        event.cbOptions.isSampleCreate = true;
      }
      _fsm-&gt;processEventThrow(event); 
      
    }
    
  }

  void Document::initFSM()
  {
  
    _fsm_organization = new XsdFSM&lt;organization_ptr&gt;( Particle(new DOMString("urn:org"),  DOMString("organization"), 1, 1),  XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;organization_ptr, Document, FsmCbOptions&gt;(this, &Document::create_organization));
  
    XsdFsmBasePtr elemFsms[] = {
    _fsm_organization,
      
      NULL
    };
    XsdFsmBasePtr fofElem = new XsdFsmOfFSMs(elemFsms, XsdFsmOfFSMs::CHOICE);
    
    XsdFsmBasePtr docEndFsm = new XsdFSM&lt;void *&gt;(Particle(NULL, "", 1, 1), XsdEvent::DOCUMENT_END);
    XsdFsmBasePtr ptrFsms[] = { fofElem,  docEndFsm, NULL };
    _fsm = new XsdFsmOfFSMs(ptrFsms, XsdFsmOfFSMs::SEQUENCE);
  }

  


  /* element functions  */
  

  organization_ptr Document::create_organization(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("organization");
    static DOMStringPtr myNsUri = new DOMString("urn:org");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this, this, _fsm, options, false, false, false);
    organization_p node = XSD::createElementTmpl&lt;organization, void*&gt;(t);
          
    _organization = node;
      
    return node;
  }

  
  organization_p Document::element_organization()
  {
    FSM::warnNullNode(_organization, "organization", "{}organization", 1);
    return _organization;
  }
    
} // end namespace org</pre>
</div>
<br><br>
<h3><a name="examples_org_src_org_organization.cpp">examples/org/src/org/organization.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "org/organization.h"

namespace org {
    

  //constructor
  
  organization::organization(ElementCreateArgs args):
      XMLSchema::XmlElement&lt;anyType&gt;(args),
    
    _fsmElems(NULL),
    _fsmAttrs(NULL)
  
    , _sequence(new sequence(this) )
  
  {
    this-&gt;contentTypeVariety(CONTENT_TYPE_VARIETY_ELEMENT_ONLY);
    initFSM();
    if(args.ownerDoc && args.ownerDoc-&gt;buildTree())
    {
      if(args.ownerDoc-&gt;createSample()) {
        _fsm-&gt;fireSampleEvents();
      }
      else {
        _fsm-&gt;fireRequiredEvents();
      }
    }
  }
    
  void organization::initFSM()
  {
    XsdFsmBasePtr fsmsAttrs[] = {
  new XsdFSM&lt;attr_id_ptr&gt;( Particle(NULL, DOMString("id"), 1, 1), XsdEvent::ATTRIBUTE, new object_unary_mem_fun_t&lt;attr_id_ptr, organization, FsmCbOptions&gt;(this, &organization::create_attr_id)),
  
      NULL
    };

    _fsm-&gt;replaceOrAppendUniqueAttributeFsms(fsmsAttrs);
  
    _fsm-&gt;replaceContentFsm(_sequence);
      
    _fsmAttrs = _fsm-&gt;attributeFsm();
    _fsmElems = _fsm-&gt;contentFsm();

  }

  /* element functions  */
  

  org::hr::leaderId_ptr organization::create_leaderId(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("leaderId");
    static DOMStringPtr myNsUri = new DOMString("urn:org:hr");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false);
    org::hr::leaderId_p node = XSD::createElementTmpl&lt;leaderId, void*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _leaderId = node;
      
    return node;
  }

  
  org::hr::leaderId_p organization::element_leaderId()
  {
    FSM::warnNullNode(_leaderId, "leaderId", "{urn:org:hr}leaderId", 1);
    return _leaderId;
  }
    
  void organization::set_leaderId(DOMString val)
  {
    get_sequence()-&gt;set_leaderId(val);
  }

  DOMString organization::get_leaderId_string()
  {
    return get_sequence()-&gt;get_leaderId_string();
  }

          

  organization::name_ptr organization::create_name(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("name");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "http://www.w3.org/2001/XMLSchema", "string");
    organization::name_p node = XSD::createElementTmpl&lt;name, XMLSchema::Types::bt_string*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _name = node;
      
    return node;
  }

  
  organization::name_p organization::element_name()
  {
    FSM::warnNullNode(_name, "name", "{http://www.w3.org/2001/XMLSchema}name", 1);
    return _name;
  }
    
  void organization::set_name(DOMString val)
  {
    get_sequence()-&gt;set_name(val);
  }

  DOMString organization::get_name_string()
  {
    return get_sequence()-&gt;get_name_string();
  }

          

  organization::departments_ptr organization::create_departments(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("departments");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "urn:org", "Departments");
    organization::departments_p node = XSD::createElementTmpl&lt;departments, org::Types::Departments*&gt;(t);
          
    _departments = node;
      
    return node;
  }

  
  organization::departments_p organization::element_departments()
  {
    FSM::warnNullNode(_departments, "departments", "{urn:org}departments", 1);
    return _departments;
  }
    

  organization::allEmployees_ptr organization::create_allEmployees(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("allEmployees");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "urn:org:hr", "AllEmployees");
    organization::allEmployees_p node = XSD::createElementTmpl&lt;allEmployees, org::hr::Types::AllEmployees*&gt;(t);
          
    _allEmployees = node;
      
    return node;
  }

  
  organization::allEmployees_p organization::element_allEmployees()
  {
    FSM::warnNullNode(_allEmployees, "allEmployees", "{urn:org:hr}allEmployees", 1);
    return _allEmployees;
  }
      

  /* attribute  functions  */
  

  organization::attr_id_ptr organization::create_attr_id(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("id");
    static DOMStringPtr myNsUri = NULL;
    
    if(_attr_id) {
      return _attr_id;
    }  
    XSD::StructCreateAttrThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options);
    organization::attr_id_p node = XSD::createAttributeTmpl&lt;attr_id&gt;(t);
      
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _attr_id = node;
      
    return node;
  }

  
    void organization::set_attr_id(DOMString val)
    {
        
      attribute_attr_id()-&gt;stringValue(val);
    }

    DOMString organization::get_attr_id_string()
    {
       
      return attribute_attr_id()-&gt;stringValue();
    }

    
  organization::attr_id_p organization::attribute_attr_id()
  {
    FSM::warnNullNode(_attr_id, "attr_id", "{http://www.w3.org/2001/XMLSchema}id", 1);
    return _attr_id;
  }
    
  //constructor
  organization::sequence::sequence(organization* that):
    _that(that)
  {
    XsdFsmBasePtr fsmArray[] = {
    new XsdFSM&lt;leaderId_ptr&gt;( Particle(new DOMString("urn:org:hr"), DOMString("leaderId"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;leaderId_ptr, organization, FsmCbOptions&gt;(_that, &organization::create_leaderId)),
      new XsdFSM&lt;name_ptr&gt;( Particle(NULL, DOMString("name"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;name_ptr, organization, FsmCbOptions&gt;(_that, &organization::create_name)),
      new XsdFSM&lt;departments_ptr&gt;( Particle(NULL, DOMString("departments"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;departments_ptr, organization, FsmCbOptions&gt;(_that, &organization::create_departments)),
      new XsdFSM&lt;allEmployees_ptr&gt;( Particle(NULL, DOMString("allEmployees"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;allEmployees_ptr, organization, FsmCbOptions&gt;(_that, &organization::create_allEmployees)),
             
      NULL 
    } ;
    
    XsdSequenceFsmOfFSMs::init(fsmArray);
  }

      

  org::hr::leaderId_p organization::sequence::element_leaderId()
  {
      org::hr::leaderId_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[0].get();
    if(fsm_p) 
    {
      XsdFSM&lt;leaderId_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;leaderId_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "leaderId", "{urn:org:hr}leaderId", 1);
    return node_p;
        
  }
  
  
  void organization::sequence::set_leaderId(DOMString val)
  {
      
    element_leaderId()-&gt;stringValue(val);
  }

  DOMString organization::sequence::get_leaderId_string()
  {
    return element_leaderId()-&gt;stringValue();
  }

          

  organization::name_p organization::sequence::element_name()
  {
      organization::name_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[1].get();
    if(fsm_p) 
    {
      XsdFSM&lt;name_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;name_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "name", "{http://www.w3.org/2001/XMLSchema}name", 1);
    return node_p;
        
  }
  
  
  void organization::sequence::set_name(DOMString val)
  {
      
    element_name()-&gt;stringValue(val);
  }

  DOMString organization::sequence::get_name_string()
  {
    return element_name()-&gt;stringValue();
  }

          

  organization::departments_p organization::sequence::element_departments()
  {
      organization::departments_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[2].get();
    if(fsm_p) 
    {
      XsdFSM&lt;departments_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;departments_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "departments", "{urn:org}departments", 1);
    return node_p;
        
  }
  
      

  organization::allEmployees_p organization::sequence::element_allEmployees()
  {
      organization::allEmployees_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[3].get();
    if(fsm_p) 
    {
      XsdFSM&lt;allEmployees_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;allEmployees_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "allEmployees", "{urn:org:hr}allEmployees", 1);
    return node_p;
        
  }
  
  
} // end namespace org</pre>
</div>
<br><br>
<h3><a name="examples_org_src_org_Types_Departments.cpp">examples/org/src/org/Types/Departments.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "org/Types/Departments.h"

namespace org {
    
namespace Types
{
  XSD::TypeDefinitionFactoryTmpl&lt;XmlElement&lt;Departments&gt; &gt; Departments::s_typeRegistry("Departments", "urn:org");

  

  //constructor
  
  Departments::Departments(AnyTypeCreateArgs args):
  XMLSchema::Types::anyType(AnyTypeCreateArgs(false, 
                                              args.ownerNode, 
                                              args.ownerElem, 
                                              args.ownerDoc, 
                                              args.childBuildsTree, 
                                              (args.createFromElementAttr? false : args.abstract),
                                              args.blockMask,
                                              args.finalMask,
                                              args.contentTypeVariety,
                                              args.anyTypeUseCase,
                                              args.suppressTypeAbstract
                                             )),
    
    _fsmElems(NULL),
    _fsmAttrs(NULL)
  
    , _sequence(new sequence(this) )
  
  {
    this-&gt;contentTypeVariety(CONTENT_TYPE_VARIETY_ELEMENT_ONLY);
    initFSM();
    if(args.ownerDoc && args.ownerDoc-&gt;buildTree() && !args.childBuildsTree)
    {
      if(args.ownerDoc-&gt;createSample()) {
        _fsm-&gt;fireSampleEvents();
      }
      else {
        _fsm-&gt;fireRequiredEvents();
      }
    }
  }
    
  void Departments::initFSM()
  {
    XsdFsmBasePtr fsmsAttrs[] = {
  
      NULL
    };

    _fsm-&gt;replaceOrAppendUniqueAttributeFsms(fsmsAttrs);
  
    _fsm-&gt;replaceContentFsm(_sequence);
      
    _fsmAttrs = _fsm-&gt;attributeFsm();
    _fsmElems = _fsm-&gt;contentFsm();

  }

  /* element functions  */
  

  Departments::engineering_ptr Departments::create_engineering(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("engineering");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "urn:org:engg", "EnggDept");
    Departments::engineering_p node = XSD::createElementTmpl&lt;engineering, org::engg::Types::EnggDept*&gt;(t);
          
    _engineering = node;
      
    return node;
  }

  
  Departments::engineering_p Departments::element_engineering()
  {
    FSM::warnNullNode(_engineering, "engineering", "{urn:org:engg}engineering", 1);
    return _engineering;
  }
    

  Departments::legal_ptr Departments::create_legal(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("legal");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "urn:org:legal", "LegalDept");
    Departments::legal_p node = XSD::createElementTmpl&lt;legal, org::legal::Types::LegalDept*&gt;(t);
          
    _legal = node;
      
    return node;
  }

  
  Departments::legal_p Departments::element_legal()
  {
    FSM::warnNullNode(_legal, "legal", "{urn:org:legal}legal", 1);
    return _legal;
  }
      

  /* attribute  functions  */
  
  //constructor
  Departments::sequence::sequence(Departments* that):
    _that(that)
  {
    XsdFsmBasePtr fsmArray[] = {
    new XsdFSM&lt;engineering_ptr&gt;( Particle(NULL, DOMString("engineering"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;engineering_ptr, Departments, FsmCbOptions&gt;(_that, &Departments::create_engineering)),
      new XsdFSM&lt;legal_ptr&gt;( Particle(NULL, DOMString("legal"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;legal_ptr, Departments, FsmCbOptions&gt;(_that, &Departments::create_legal)),
             
      NULL 
    } ;
    
    XsdSequenceFsmOfFSMs::init(fsmArray);
  }

      

  Departments::engineering_p Departments::sequence::element_engineering()
  {
      Departments::engineering_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[0].get();
    if(fsm_p) 
    {
      XsdFSM&lt;engineering_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;engineering_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "engineering", "{urn:org:engg}engineering", 1);
    return node_p;
        
  }
  
      

  Departments::legal_p Departments::sequence::element_legal()
  {
      Departments::legal_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[1].get();
    if(fsm_p) 
    {
      XsdFSM&lt;legal_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;legal_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "legal", "{urn:org:legal}legal", 1);
    return node_p;
        
  }
  
  
} //  end namespace Types 


} // end namespace org</pre>
</div>
<br><br>
<h3><a name="examples_org_src_org_legal_Types_LegalDept.cpp">examples/org/src/org_legal/Types/LegalDept.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "org_legal/Types/LegalDept.h"

namespace org {
      
namespace legal {
    
namespace Types
{
  XSD::TypeDefinitionFactoryTmpl&lt;XmlElement&lt;LegalDept&gt; &gt; LegalDept::s_typeRegistry("LegalDept", "urn:org:legal");

  

  //constructor
  
  LegalDept::LegalDept(AnyTypeCreateArgs args):
  XMLSchema::Types::anyType(AnyTypeCreateArgs(false, 
                                              args.ownerNode, 
                                              args.ownerElem, 
                                              args.ownerDoc, 
                                              args.childBuildsTree, 
                                              (args.createFromElementAttr? false : args.abstract),
                                              args.blockMask,
                                              args.finalMask,
                                              args.contentTypeVariety,
                                              args.anyTypeUseCase,
                                              args.suppressTypeAbstract
                                             )),
    
    _fsmElems(NULL),
    _fsmAttrs(NULL)
  
    , _sequence(new sequence(this) )
  
  {
    this-&gt;contentTypeVariety(CONTENT_TYPE_VARIETY_ELEMENT_ONLY);
    initFSM();
    if(args.ownerDoc && args.ownerDoc-&gt;buildTree() && !args.childBuildsTree)
    {
      if(args.ownerDoc-&gt;createSample()) {
        _fsm-&gt;fireSampleEvents();
      }
      else {
        _fsm-&gt;fireRequiredEvents();
      }
    }
  }
    
  void LegalDept::initFSM()
  {
    XsdFsmBasePtr fsmsAttrs[] = {
  new XsdFSM&lt;attr_id_ptr&gt;( Particle(NULL, DOMString("id"), 1, 1), XsdEvent::ATTRIBUTE, new object_unary_mem_fun_t&lt;attr_id_ptr, LegalDept, FsmCbOptions&gt;(this, &LegalDept::create_attr_id)),
  
      NULL
    };

    _fsm-&gt;replaceOrAppendUniqueAttributeFsms(fsmsAttrs);
  
    _fsm-&gt;replaceContentFsm(_sequence);
      
    _fsmAttrs = _fsm-&gt;attributeFsm();
    _fsmElems = _fsm-&gt;contentFsm();

  }

  /* element functions  */
  

  org::hr::leaderId_ptr LegalDept::create_leaderId(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("leaderId");
    static DOMStringPtr myNsUri = new DOMString("urn:org:hr");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false);
    org::hr::leaderId_p node = XSD::createElementTmpl&lt;leaderId, void*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _leaderId = node;
      
    return node;
  }

  
  org::hr::leaderId_p LegalDept::element_leaderId()
  {
    FSM::warnNullNode(_leaderId, "leaderId", "{urn:org:hr}leaderId", 1);
    return _leaderId;
  }
    
  void LegalDept::set_leaderId(DOMString val)
  {
    get_sequence()-&gt;set_leaderId(val);
  }

  DOMString LegalDept::get_leaderId_string()
  {
    return get_sequence()-&gt;get_leaderId_string();
  }

          

  LegalDept::legalAdvisors_ptr LegalDept::create_legalAdvisors(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("legalAdvisors");
    static DOMStringPtr myNsUri = NULL;
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false, "urn:org:hr", "UserIdList");
    LegalDept::legalAdvisors_p node = XSD::createElementTmpl&lt;legalAdvisors, org::hr::Types::UserIdList*&gt;(t);
          
    _legalAdvisors = node;
      
    return node;
  }

  
  LegalDept::legalAdvisors_p LegalDept::element_legalAdvisors()
  {
    FSM::warnNullNode(_legalAdvisors, "legalAdvisors", "{urn:org:hr}legalAdvisors", 1);
    return _legalAdvisors;
  }
      

  /* attribute  functions  */
  

  LegalDept::attr_id_ptr LegalDept::create_attr_id(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("id");
    static DOMStringPtr myNsUri = NULL;
    
    if(_attr_id) {
      return _attr_id;
    }  
    XSD::StructCreateAttrThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options);
    LegalDept::attr_id_p node = XSD::createAttributeTmpl&lt;attr_id&gt;(t);
      
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _attr_id = node;
      
    return node;
  }

  
    void LegalDept::set_attr_id(DOMString val)
    {
        
      attribute_attr_id()-&gt;stringValue(val);
    }

    DOMString LegalDept::get_attr_id_string()
    {
       
      return attribute_attr_id()-&gt;stringValue();
    }

    
  LegalDept::attr_id_p LegalDept::attribute_attr_id()
  {
    FSM::warnNullNode(_attr_id, "attr_id", "{http://www.w3.org/2001/XMLSchema}id", 1);
    return _attr_id;
  }
    
  //constructor
  LegalDept::sequence::sequence(LegalDept* that):
    _that(that)
  {
    XsdFsmBasePtr fsmArray[] = {
    new XsdFSM&lt;leaderId_ptr&gt;( Particle(new DOMString("urn:org:hr"), DOMString("leaderId"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;leaderId_ptr, LegalDept, FsmCbOptions&gt;(_that, &LegalDept::create_leaderId)),
      new XsdFSM&lt;legalAdvisors_ptr&gt;( Particle(NULL, DOMString("legalAdvisors"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;legalAdvisors_ptr, LegalDept, FsmCbOptions&gt;(_that, &LegalDept::create_legalAdvisors)),
             
      NULL 
    } ;
    
    XsdSequenceFsmOfFSMs::init(fsmArray);
  }

      

  org::hr::leaderId_p LegalDept::sequence::element_leaderId()
  {
      org::hr::leaderId_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[0].get();
    if(fsm_p) 
    {
      XsdFSM&lt;leaderId_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;leaderId_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "leaderId", "{urn:org:hr}leaderId", 1);
    return node_p;
        
  }
  
  
  void LegalDept::sequence::set_leaderId(DOMString val)
  {
      
    element_leaderId()-&gt;stringValue(val);
  }

  DOMString LegalDept::sequence::get_leaderId_string()
  {
    return element_leaderId()-&gt;stringValue();
  }

          

  LegalDept::legalAdvisors_p LegalDept::sequence::element_legalAdvisors()
  {
      LegalDept::legalAdvisors_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[1].get();
    if(fsm_p) 
    {
      XsdFSM&lt;legalAdvisors_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;legalAdvisors_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "legalAdvisors", "{urn:org:hr}legalAdvisors", 1);
    return node_p;
        
  }
  
  
} //  end namespace Types 


} // end namespace legal  
} // end namespace org</pre>
</div>
<br><br>
<br>
<h2><a name="examples_netEnabled">examples/netEnabled</a></h2>
<hr NOSHADE SIZE=2 WIDTH=100%>
<ul>
 <li> <b>README files</b>
  <ul>
   <li> <a href="#examples_netEnabled_README.txt">examples/netEnabled/README.txt</a>
  </ul>
<br><br>
 <li> <b>XML Schema Files</b>
  <ul>
   <li> <b><a href="#examples_netEnabled_netEnabled.xsd">examples/netEnabled/netEnabled.xsd</a></b><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => Input XML Schema</code>
  </ul>
<br><br>
 <li> <b>Related XML Files</b>
  <ul>
   <li> <a href="#examples_netEnabled_echoHexBinaryElement-HexBinaryElement01.xml">examples/netEnabled/echoHexBinaryElement-HexBinaryElement01.xml</a>
   <li> <a href="#examples_netEnabled_echoHexBinaryElement-HexBinaryElement02.xml">examples/netEnabled/echoHexBinaryElement-HexBinaryElement02.xml</a>
   <li> <a href="#examples_netEnabled_nsaliases.xml">examples/netEnabled/nsaliases.xml</a>
   <li> <a href="#examples_netEnabled_valid.xml">examples/netEnabled/valid.xml</a>
  </ul>
<br><br>
 <li> <b>Files generated using <i>xsd2cpp</i></b> (along with directory structure)
  <ul>
<br>
 <li> <i>Generated Header(.h) Files</i>
  <ul>
   <li> <a href="#examples_netEnabled_include_examples_6_05_echoHexBinaryElement.h">examples/netEnabled/include/examples_6_05/echoHexBinaryElement.h</a>
   <li> <a href="#examples_netEnabled_include_examples_6_05_Document.h">examples/netEnabled/include/examples_6_05/Document.h</a>
   <li> <a href="#examples_netEnabled_include_examples_6_05_echo.h">examples/netEnabled/include/examples_6_05/echo.h</a>
   <li> <a href="#examples_netEnabled_include_examples_6_05_all-include.h">examples/netEnabled/include/examples_6_05/all-include.h</a>
   <li> <a href="#examples_netEnabled_include_examples_6_05_hexBinaryElement.h">examples/netEnabled/include/examples_6_05/hexBinaryElement.h</a>
  </ul>
<br>
 <li> <i>Generated Implementation(.cpp) Files</i>
  <ul>
   <li> <a href="#examples_netEnabled_main.cpp">examples/netEnabled/main.cpp</a>
   <li> <a href="#examples_netEnabled_src_examples_6_05_Document.cpp">examples/netEnabled/src/examples_6_05/Document.cpp</a>
   <li> <a href="#examples_netEnabled_src_examples_6_05_echoHexBinaryElement.cpp">examples/netEnabled/src/examples_6_05/echoHexBinaryElement.cpp</a>
   <li> <a href="#examples_netEnabled_src_examples_6_05_echo.cpp">examples/netEnabled/src/examples_6_05/echo.cpp</a>
  </ul>
  </ul>
<br><br>
</ul>
<h3><a name="examples_netEnabled_README.txt">examples/netEnabled/README.txt</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 This example(netEnabled) demonstrates the "network-enabled processor" capability of xsd2cpp.

 The netEnabled.xsd document includes a XML Schema located on world-wide-web:
   schemaLocation="http://www.w3.org/2002/ws/databinding/examples/6/05/HexBinaryElement/echoHexBinaryElement.xsd"

 For xsd2cpp to work sucessfully:
  - the world-wide-web must be accessible on machine(internet)
  - the schemaLocation URL must be valid, and available on WWW.


 Since xsd2cpp is also a "minimally-conforming processor", with "network-enabled processor" capability, it qualifies to become "Fully conforming processor".


 Related definitions from W3C specification:
 ===========================================

  link:
    http://www.w3.org/TR/xmlschema-1/XML%20Schema%20Part%201_%20Structures%20Second%20Edition.html#key-fullyConforming

  [Definition:]  Minimally conforming processors must completely and correctly implement the ·Schema Component Constraints·, ·Validation Rules·, and ·Schema Information Set Contributions· contained in this specification.

  [Definition:]  ·Minimally conforming· processors which accept schemas represented in the form of XML documents as described in Layer 2: Schema Documents, Namespaces and Composition (§4.2) are additionally said to provide conformance to the XML Representation of Schemas. Such processors must, when processing schema documents, completely and correctly implement all ·Schema Representation Constraints· in this specification, and must adhere exactly to the specifications in Schema Component Details (§3) for mapping the contents of such documents to ·schema components· for use in ·validation· and ·assessment·.

  [Definition:]   Fully conforming processors are network-enabled processors which are not only both ·minimally conforming· and ·in conformance to the XML Representation of Schemas·, but which additionally must be capable of accessing schema documents from the World Wide Web according to Representation of Schemas on the World Wide Web (§2.7) and How schema definitions are located on the Web (§4.3.2). .

</pre>
</div>
<br><br>
<h3><a name="examples_netEnabled_netEnabled.xsd">examples/netEnabled/netEnabled.xsd</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  targetNamespace="http://www.w3.org/2002/ws/databinding/examples/6/05/"
  xmlns="http://www.w3.org/2002/ws/databinding/examples/6/05/"
  xmlns:ns1="http://www.w3.org/2002/ws/databinding/examples/6/05/"
  &gt;

  &lt;xsd:include schemaLocation="http://www.w3.org/2002/ws/databinding/examples/6/05/HexBinaryElement/echoHexBinaryElement.xsd"/&gt;

  
  &lt;xsd:element name="echo"&gt; 
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="ns1:echoHexBinaryElement"/&gt; 
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

&lt;/xsd:schema&gt;
</pre>
</div>
<br><br>
<h3><a name="examples_netEnabled_echoHexBinaryElement-HexBinaryElement01.xml">examples/netEnabled/echoHexBinaryElement-HexBinaryElement01.xml</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--

    Copyright (C) 2006 W3C (R) (MIT ERCIM Keio), All Rights Reserved.
    W3C liability, trademark and document use rules apply.

    http://www.w3.org/Consortium/Legal/ipr-notice
    http://www.w3.org/Consortium/Legal/copyright-documents

    $Header: /w3ccvs/WWW/2002/ws/databinding/examples/6/05/HexBinaryElement/echoHexBinaryElement-HexBinaryElement01.xml,v 1.1 2006/09/05 15:07:00 pdowney Exp $

--&gt;
&lt;ex:echoHexBinaryElement xmlns:ex="http://www.w3.org/2002/ws/databinding/examples/6/05/"&gt;
  &lt;ex:hexBinaryElement xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;76&lt;/ex:hexBinaryElement&gt;
&lt;/ex:echoHexBinaryElement&gt;
</pre>
</div>
<br><br>
<h3><a name="examples_netEnabled_echoHexBinaryElement-HexBinaryElement02.xml">examples/netEnabled/echoHexBinaryElement-HexBinaryElement02.xml</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--

    Copyright (C) 2006 W3C (R) (MIT ERCIM Keio), All Rights Reserved.
    W3C liability, trademark and document use rules apply.

    http://www.w3.org/Consortium/Legal/ipr-notice
    http://www.w3.org/Consortium/Legal/copyright-documents

    $Header: /w3ccvs/WWW/2002/ws/databinding/examples/6/05/HexBinaryElement/echoHexBinaryElement-HexBinaryElement02.xml,v 1.1 2006/09/05 15:07:00 pdowney Exp $

--&gt;
&lt;ex:echoHexBinaryElement xmlns:ex="http://www.w3.org/2002/ws/databinding/examples/6/05/"&gt;
  &lt;ex:hexBinaryElement xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;77696f646d6f6e7974637174716a7169696e6b65616f76786f746e66716b707875757261736e686469796b65706c656d7465626661637661646e6b65636662647669726d6f6e757361&lt;/ex:hexBinaryElement&gt;
&lt;/ex:echoHexBinaryElement&gt;
</pre>
</div>
<br><br>
<h3><a name="examples_netEnabled_nsaliases.xml">examples/netEnabled/nsaliases.xml</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;nsaliases&gt;
  &lt;alias uri="http://www.w3.org/2002/ws/databinding/examples/6/05/" toUrn="urn:examples_6_05"/&gt;
&lt;/nsaliases&gt;
</pre>
</div>
<br><br>
<h3><a name="examples_netEnabled_valid.xml">examples/netEnabled/valid.xml</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;ns1:echo xmlns:ns1="http://www.w3.org/2002/ws/databinding/examples/6/05/"&gt;
  &lt;ns1:echoHexBinaryElement&gt;
    &lt;ns1:hexBinaryElement&gt;77696f646d6f6e7974637174716a7169696e6b65616f76786f746e66716b707875757261736e686469796b65706c656d7465626661637661646e6b65636662647669726d6f6e757361&lt;/ns1:hexBinaryElement&gt;
  &lt;/ns1:echoHexBinaryElement&gt;
&lt;/ns1:echo&gt;</pre>
</div>
<br><br>
<h3><a name="examples_netEnabled_include_examples_6_05_echoHexBinaryElement.h">examples/netEnabled/include/examples_6_05/echoHexBinaryElement.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __examples_6_05_echoHexBinaryElement_H__
#define  __examples_6_05_echoHexBinaryElement_H__
#include "XSD/UrTypes.h"
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"


#include "examples_6_05/hexBinaryElement.h"
      

using namespace XPlus;

namespace examples_6_05{


/// The class for element {}echoHexBinaryElement with following structure: 
/// \n complexType-&gt;ModelGroup-or-ModelGroupDefinition
/// Read more on structures/methods inside ...
class echoHexBinaryElement : public XMLSchema::XmlElement&lt;XMLSchema::Types::anyType&gt;
{
  public:

    /// constructor for the element node
    echoHexBinaryElement(ElementCreateArgs args);

  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;examples_6_05::hexBinaryElement &gt; hexBinaryElement_ptr;
  /// typedef for the Plain pointer to the node
  typedef examples_6_05::hexBinaryElement* hexBinaryElement_p;
  
  /// typedef for the node
  typedef examples_6_05::hexBinaryElement hexBinaryElement; 
  
  /// The MG class inside a complexType
  /// \n Refer to documentation on structures/methods inside ...
  struct sequence : public XsdSequenceFsmOfFSMs 
  {
      

    /// constructor for the MG node
    sequence(echoHexBinaryElement* that);

    

    ///  For the scalar-element with QName "{http://www.w3.org/2002/ws/databinding/examples/6/05/}hexBinaryElement" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    hexBinaryElement_p element_hexBinaryElement();

        

    ///  For the scalar-element with QName "{http://www.w3.org/2002/ws/databinding/examples/6/05/}hexBinaryElement" :
    ///  \n Sets the value of the scalar element with the supplied value.
    ///  @param val the value(as DOMString) to set with 
    void set_hexBinaryElement(DOMString val);

    ///  For the scalar-element with QName "{http://www.w3.org/2002/ws/databinding/examples/6/05/}hexBinaryElement" :
    ///  \n Returns the value of the scalar element 
    ///  @return the value(as DOMString) of the element 
    DOMString get_hexBinaryElement_string();

          

    //  accessors for MGs/MGDs which are nested children of this MG/MGD
    

  private:  

    inline XsdFsmBase* clone() const {
      return new sequence(*this);
    }

    echoHexBinaryElement*      _that;
  }; // end sequence
  

  ///  For the scalar-element with QName "{http://www.w3.org/2002/ws/databinding/examples/6/05/}hexBinaryElement" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  hexBinaryElement_p element_hexBinaryElement();
      

  ///  For the scalar-element with QName "{http://www.w3.org/2002/ws/databinding/examples/6/05/}hexBinaryElement" :
  ///  \n Sets the value of the element with the supplied value.
  ///  @param val the value(as DOMString) to set with 
  void set_hexBinaryElement(DOMString val);
  
  ///  For the scalar-element with QName "{http://www.w3.org/2002/ws/databinding/examples/6/05/}hexBinaryElement" :
  ///  \n Returns the value(as DOMString) of the element
  DOMString get_hexBinaryElement_string();

        

  /// Returns the MG node(or node-list) inside  the complexType 
  sequence*  get_sequence() {
    return _sequence;
  }

    

  protected:
  
  XsdAllFsmOfFSMsPtr   _fsmAttrs;   
  XsdFsmBasePtr        _fsmElems;   
  
  
  AutoPtr&lt;sequence&gt; _sequence;
    
    
  hexBinaryElement_ptr _hexBinaryElement;
              

  /// initialize the FSM
  void initFSM();

  
  hexBinaryElement_ptr create_hexBinaryElement(FsmCbOptions& options);
  

public:

  //types which this class needs, as INNER CLASSES
  
  //types which this class needs, as INNER CLASSES : END



}; //end class echoHexBinaryElement

  //
  // Following types(mostly typedefs) are the ones, based on above C++ class definition
  // for the top-level element {}echoHexBinaryElement
  //


  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;echoHexBinaryElement &gt; echoHexBinaryElement_ptr;
  /// typedef for the Plain pointer to the node
  typedef echoHexBinaryElement* echoHexBinaryElement_p;
  
} // end namespace      
    
#endif
</pre>
</div>
<br><br>
<h3><a name="examples_netEnabled_include_examples_6_05_Document.h">examples/netEnabled/include/examples_6_05/Document.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __examples_6_05_DOCUMENT_H__
#define  __examples_6_05_DOCUMENT_H__
        
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"

#include "examples_6_05/echo.h"
    
#include "examples_6_05/hexBinaryElement.h"
    
#include "examples_6_05/echoHexBinaryElement.h"
    

using namespace XPlus;
using namespace FSM;


namespace examples_6_05{


class Document : public XMLSchema::TDocument
{
  private:
  
  
  echo_ptr _echo;
    
  AutoPtr&lt;XsdFSM&lt;echo_ptr&gt; &gt; _fsm_echo;
  
  hexBinaryElement_ptr _hexBinaryElement;
    
  XsdFSM&lt;hexBinaryElement_ptr&gt;* _fsm_hexBinaryElement;
    
  echoHexBinaryElement_ptr _echoHexBinaryElement;
    
  XsdFSM&lt;echoHexBinaryElement_ptr&gt;* _fsm_echoHexBinaryElement;
      
  
  // attributes, elements
  
  echo_ptr create_echo(FsmCbOptions& options);

  hexBinaryElement_ptr create_hexBinaryElement(FsmCbOptions& options);

  echoHexBinaryElement_ptr create_echoHexBinaryElement(FsmCbOptions& options);
  

  public:

  Document(bool buildTree=true, bool createSample=false);
  virtual ~Document() {}
    
  
  void set_root_echo();
    
  void set_root_hexBinaryElement();
    
  void set_root_echoHexBinaryElement();
    
  echo_p element_echo();
  
  hexBinaryElement_p element_hexBinaryElement();
    
  echoHexBinaryElement_p element_echoHexBinaryElement();
      
    
  void initFSM();
};

} // end namespace      
    
#endif
  </pre>
</div>
<br><br>
<h3><a name="examples_netEnabled_include_examples_6_05_echo.h">examples/netEnabled/include/examples_6_05/echo.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __examples_6_05_echo_H__
#define  __examples_6_05_echo_H__
#include "XSD/UrTypes.h"
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"


#include "examples_6_05/echoHexBinaryElement.h"
      

using namespace XPlus;

namespace examples_6_05{


/// The class for element {http://www.w3.org/2002/ws/databinding/examples/6/05/}echo with following structure: 
/// \n complexType-&gt;ModelGroup-or-ModelGroupDefinition
/// Read more on structures/methods inside ...
class echo : public XMLSchema::XmlElement&lt;XMLSchema::Types::anyType&gt;
{
  public:

    /// constructor for the element node
    echo(ElementCreateArgs args);

  

  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;examples_6_05::echoHexBinaryElement &gt; echoHexBinaryElement_ptr;
  /// typedef for the Plain pointer to the node
  typedef examples_6_05::echoHexBinaryElement* echoHexBinaryElement_p;
  
  /// typedef for the node
  typedef examples_6_05::echoHexBinaryElement echoHexBinaryElement; 
  
  /// The MG class inside a complexType
  /// \n Refer to documentation on structures/methods inside ...
  struct sequence : public XsdSequenceFsmOfFSMs 
  {
      

    /// constructor for the MG node
    sequence(echo* that);

    

    ///  For the scalar-element with QName "{http://www.w3.org/2002/ws/databinding/examples/6/05/}echoHexBinaryElement" :
    ///  \n Returns the scalar element node
    ///  @return the element node fetched
    echoHexBinaryElement_p element_echoHexBinaryElement();

        

    //  accessors for MGs/MGDs which are nested children of this MG/MGD
    

  private:  

    inline XsdFsmBase* clone() const {
      return new sequence(*this);
    }

    echo*      _that;
  }; // end sequence
  

  ///  For the scalar-element with QName "{http://www.w3.org/2002/ws/databinding/examples/6/05/}echoHexBinaryElement" :
  ///  \n Returns the scalar element node
  ///  @return the element node fetched
  echoHexBinaryElement_p element_echoHexBinaryElement();
      

  /// Returns the MG node(or node-list) inside  the complexType 
  sequence*  get_sequence() {
    return _sequence;
  }

    

  protected:
  
  XsdAllFsmOfFSMsPtr   _fsmAttrs;   
  XsdFsmBasePtr        _fsmElems;   
  
  
  AutoPtr&lt;sequence&gt; _sequence;
    
    
  echoHexBinaryElement_ptr _echoHexBinaryElement;
              

  /// initialize the FSM
  void initFSM();

  
  echoHexBinaryElement_ptr create_echoHexBinaryElement(FsmCbOptions& options);
  

public:

  //types which this class needs, as INNER CLASSES
  
  //types which this class needs, as INNER CLASSES : END



}; //end class echo

  //
  // Following types(mostly typedefs) are the ones, based on above C++ class definition
  // for the top-level element {http://www.w3.org/2002/ws/databinding/examples/6/05/}echo
  //


  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;echo &gt; echo_ptr;
  /// typedef for the Plain pointer to the node
  typedef echo* echo_p;
  
} // end namespace      
    
#endif
</pre>
</div>
<br><br>
<h3><a name="examples_netEnabled_include_examples_6_05_all-include.h">examples/netEnabled/include/examples_6_05/all-include.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __examples_6_05_ALL_INCLUDE_H__
#define  __examples_6_05_ALL_INCLUDE_H__

#include "XPlus/AutoPtr.h"

  
#include "examples_6_05/Document.h"

#include "examples_6_05/echo.h"    
  

using namespace XPlus;


#endif 
  </pre>
</div>
<br><br>
<h3><a name="examples_netEnabled_include_examples_6_05_hexBinaryElement.h">examples/netEnabled/include/examples_6_05/hexBinaryElement.h</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#ifndef  __examples_6_05_hexBinaryElement_H__
#define  __examples_6_05_hexBinaryElement_H__
#include "XSD/UrTypes.h"
#include "XSD/xsdUtils.h"
#include "XSD/TypeDefinitionFactory.h"



using namespace XPlus;

namespace examples_6_05{

  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_hexBinary&gt; hexBinaryElement;
    

  //
  // Following types(mostly typedefs) are the ones, based on above C++ class definition
  // for the top-level element {http://www.w3.org/2001/XMLSchema}hexBinaryElement
  //


  /// typedef for the Shared pointer to the node
  typedef AutoPtr&lt;XMLSchema::XmlElement&lt;XMLSchema::Types::bt_hexBinary&gt; &gt; hexBinaryElement_ptr;
  /// typedef for the Plain pointer to the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_hexBinary&gt;* hexBinaryElement_p;
  
  /// typedef for the node
  typedef XMLSchema::XmlElement&lt;XMLSchema::Types::bt_hexBinary&gt; hexBinaryElement; 
  
} // end namespace      
    
#endif
</pre>
</div>
<br><br>
<h3><a name="examples_netEnabled_main.cpp">examples/netEnabled/main.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  On subsequent "xsd2cpp" invocations, this file would not be overwritten.
 //  You can edit this file.
 //
  
#include &lt;iostream&gt;
#include &lt;string&gt;

#include "XSD/UserOps.h"
#include "examples_6_05/all-include.h"

void populateDocument(examples_6_05::Document* xsdDoc);
void updateOrConsumeDocument(examples_6_05::Document* xsdDoc);
  
void chooseDocumentElement(examples_6_05::Document* xsdDoc);
    

int main (int argc, char** argv)
{
  XSD::UserOps&lt;examples_6_05::Document&gt;::UserOpsCbStruct cbStruct;
  cbStruct.cbPopulateDocument           =  populateDocument;
  cbStruct.cbUpdateOrConsumeDocument    =  updateOrConsumeDocument;
  cbStruct.cbChooseDocumentElement      =  chooseDocumentElement;

  XSD::UserOps&lt;examples_6_05::Document&gt; opHandle(cbStruct);
  opHandle.run(argc, argv);
}

//
// Following functions are use case templates.
// You need to put "code" in the respective contexts.
//

  
// choose the element inside Document that you want as root using
// a call like : xsdDoc-&gt;set_root_xyz();
void chooseDocumentElement(examples_6_05::Document* xsdDoc)
{
  // uncomment one of folowing to choose root
  
  xsdDoc-&gt;set_root_echo();
  
  //xsdDoc-&gt;set_root_hexBinaryElement();
    
  //xsdDoc-&gt;set_root_echoHexBinaryElement();
      
}
    

// template function to populate the Tree with values
// write code to populate the Document here ...
void populateDocument(examples_6_05::Document* xsdDoc)
{
  xsdDoc-&gt;element_echo()-&gt;element_echoHexBinaryElement()-&gt;set_hexBinaryElement("77696f646d6f6e7974637174716a7169696e6b65616f76786f746e66716b707875757261736e686469796b65706c656d7465626661637661646e6b65636662647669726d6f6e757361");
}

// write code to operate(update/consume/test etc.) on the Document here...
// This Document is typically already populated(eg. read from an input
// xml file)
void updateOrConsumeDocument(examples_6_05::Document* xsdDoc)
{

}

  
</pre>
</div>
<br><br>
<h3><a name="examples_netEnabled_src_examples_6_05_Document.cpp">examples/netEnabled/src/examples_6_05/Document.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "examples_6_05/Document.h"


namespace examples_6_05{


  ///constructor for the Document node
  Document::Document(bool buildTree_, bool createSample_):
    XMLSchema::TDocument(buildTree_, createSample_)
  {
    initFSM();
    DOM::Document::attributeDefaultQualified(false);
    DOM::Document::elementDefaultQualified(false);
    
  }

  void Document::initFSM()
  {
  
    _fsm_echo = new XsdFSM&lt;echo_ptr&gt;( Particle(new DOMString("http://www.w3.org/2002/ws/databinding/examples/6/05/"),  DOMString("echo"), 1, 1),  XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;echo_ptr, Document, FsmCbOptions&gt;(this, &Document::create_echo));
  _fsm_hexBinaryElement = new XsdFSM&lt;hexBinaryElement_ptr&gt;( Particle(new DOMString("http://www.w3.org/2002/ws/databinding/examples/6/05/"),  DOMString("hexBinaryElement"), 1, 1),  XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;hexBinaryElement_ptr, Document, FsmCbOptions&gt;(this, &Document::create_hexBinaryElement));
    _fsm_echoHexBinaryElement = new XsdFSM&lt;echoHexBinaryElement_ptr&gt;( Particle(new DOMString("http://www.w3.org/2002/ws/databinding/examples/6/05/"),  DOMString("echoHexBinaryElement"), 1, 1),  XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;echoHexBinaryElement_ptr, Document, FsmCbOptions&gt;(this, &Document::create_echoHexBinaryElement));
    
    XsdFsmBasePtr elemFsms[] = {
    _fsm_echo,
    _fsm_hexBinaryElement,
    _fsm_echoHexBinaryElement,
      
      NULL
    };
    XsdFsmBasePtr fofElem = new XsdFsmOfFSMs(elemFsms, XsdFsmOfFSMs::CHOICE);
    
    XsdFsmBasePtr docEndFsm = new XsdFSM&lt;void *&gt;(Particle(NULL, "", 1, 1), XsdEvent::DOCUMENT_END);
    XsdFsmBasePtr ptrFsms[] = { fofElem,  docEndFsm, NULL };
    _fsm = new XsdFsmOfFSMs(ptrFsms, XsdFsmOfFSMs::SEQUENCE);
  }

  
    void Document::set_root_echo() 
    {
    
      if(!_echo) {
        XsdEvent event(new DOMString("http://www.w3.org/2002/ws/databinding/examples/6/05/"), NULL, DOMString("echo"), XsdEvent::ELEMENT_START);
        _fsm-&gt;processEventThrow(event); 
      }
    }
    
    void Document::set_root_hexBinaryElement() 
    {
    
      if(!_hexBinaryElement) 
      {
        XsdEvent event(new DOMString("http://www.w3.org/2002/ws/databinding/examples/6/05/"), NULL, DOMString("hexBinaryElement"), XsdEvent::ELEMENT_START);
        _fsm-&gt;processEventThrow(event); 
      }
    }
    
    void Document::set_root_echoHexBinaryElement() 
    {
    
      if(!_echoHexBinaryElement) 
      {
        XsdEvent event(new DOMString("http://www.w3.org/2002/ws/databinding/examples/6/05/"), NULL, DOMString("echoHexBinaryElement"), XsdEvent::ELEMENT_START);
        _fsm-&gt;processEventThrow(event); 
      }
    }
    


  /* element functions  */
  

  echo_ptr Document::create_echo(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("echo");
    static DOMStringPtr myNsUri = new DOMString("http://www.w3.org/2002/ws/databinding/examples/6/05/");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this, this, _fsm, options, false, false, false);
    echo_p node = XSD::createElementTmpl&lt;echo, void*&gt;(t);
          
    _echo = node;
      
    return node;
  }

  
  echo_p Document::element_echo()
  {
    FSM::warnNullNode(_echo, "echo", "{http://www.w3.org/2002/ws/databinding/examples/6/05/}echo", 1);
    return _echo;
  }
    

  hexBinaryElement_ptr Document::create_hexBinaryElement(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("hexBinaryElement");
    static DOMStringPtr myNsUri = new DOMString("http://www.w3.org/2002/ws/databinding/examples/6/05/");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this, this, _fsm, options, false, false, false, "http://www.w3.org/2001/XMLSchema", "hexBinary");
    hexBinaryElement_p node = XSD::createElementTmpl&lt;hexBinaryElement, XMLSchema::Types::bt_hexBinary*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _hexBinaryElement = node;
      
    return node;
  }

  
  hexBinaryElement_p Document::element_hexBinaryElement()
  {
    FSM::warnNullNode(_hexBinaryElement, "hexBinaryElement", "{http://www.w3.org/2001/XMLSchema}hexBinaryElement", 1);
    return _hexBinaryElement;
  }
    

  echoHexBinaryElement_ptr Document::create_echoHexBinaryElement(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("echoHexBinaryElement");
    static DOMStringPtr myNsUri = new DOMString("http://www.w3.org/2002/ws/databinding/examples/6/05/");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this, this, _fsm, options, false, false, false);
    echoHexBinaryElement_p node = XSD::createElementTmpl&lt;echoHexBinaryElement, void*&gt;(t);
          
    _echoHexBinaryElement = node;
      
    return node;
  }

  
  echoHexBinaryElement_p Document::element_echoHexBinaryElement()
  {
    FSM::warnNullNode(_echoHexBinaryElement, "echoHexBinaryElement", "{}echoHexBinaryElement", 1);
    return _echoHexBinaryElement;
  }
    
} // end namespace      
    </pre>
</div>
<br><br>
<h3><a name="examples_netEnabled_src_examples_6_05_echoHexBinaryElement.cpp">examples/netEnabled/src/examples_6_05/echoHexBinaryElement.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "examples_6_05/echoHexBinaryElement.h"

namespace examples_6_05{


  //constructor
  
  echoHexBinaryElement::echoHexBinaryElement(ElementCreateArgs args):
      XMLSchema::XmlElement&lt;anyType&gt;(args),
    
    _fsmElems(NULL),
    _fsmAttrs(NULL)
  
    , _sequence(new sequence(this) )
  
  {
    this-&gt;contentTypeVariety(CONTENT_TYPE_VARIETY_ELEMENT_ONLY);
    initFSM();
    if(args.ownerDoc && args.ownerDoc-&gt;buildTree())
    {
      if(args.ownerDoc-&gt;createSample()) {
        _fsm-&gt;fireSampleEvents();
      }
      else {
        _fsm-&gt;fireRequiredEvents();
      }
    }
  }
    
  void echoHexBinaryElement::initFSM()
  {
    XsdFsmBasePtr fsmsAttrs[] = {
  
      NULL
    };

    _fsm-&gt;replaceOrAppendUniqueAttributeFsms(fsmsAttrs);
  
    _fsm-&gt;replaceContentFsm(_sequence);
      
    _fsmAttrs = _fsm-&gt;attributeFsm();
    _fsmElems = _fsm-&gt;contentFsm();

  }

  /* element functions  */
  

  hexBinaryElement_ptr echoHexBinaryElement::create_hexBinaryElement(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("hexBinaryElement");
    static DOMStringPtr myNsUri = new DOMString("http://www.w3.org/2002/ws/databinding/examples/6/05/");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false);
    hexBinaryElement_p node = XSD::createElementTmpl&lt;hexBinaryElement, void*&gt;(t);
          
    if(options.isSampleCreate && (node-&gt;stringValue() == "") ) {
      node-&gt;stringValue(node-&gt;sampleValue());
    }
    
    _hexBinaryElement = node;
      
    return node;
  }

  
  hexBinaryElement_p echoHexBinaryElement::element_hexBinaryElement()
  {
    FSM::warnNullNode(_hexBinaryElement, "hexBinaryElement", "{http://www.w3.org/2002/ws/databinding/examples/6/05/}hexBinaryElement", 1);
    return _hexBinaryElement;
  }
    
  void echoHexBinaryElement::set_hexBinaryElement(DOMString val)
  {
    get_sequence()-&gt;set_hexBinaryElement(val);
  }

  DOMString echoHexBinaryElement::get_hexBinaryElement_string()
  {
    return get_sequence()-&gt;get_hexBinaryElement_string();
  }

            

  /* attribute  functions  */
  
  //constructor
  echoHexBinaryElement::sequence::sequence(echoHexBinaryElement* that):
    _that(that)
  {
    XsdFsmBasePtr fsmArray[] = {
    new XsdFSM&lt;hexBinaryElement_ptr&gt;( Particle(new DOMString("http://www.w3.org/2002/ws/databinding/examples/6/05/"), DOMString("hexBinaryElement"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;hexBinaryElement_ptr, echoHexBinaryElement, FsmCbOptions&gt;(_that, &echoHexBinaryElement::create_hexBinaryElement)),
             
      NULL 
    } ;
    
    XsdSequenceFsmOfFSMs::init(fsmArray);
  }

      

  hexBinaryElement_p echoHexBinaryElement::sequence::element_hexBinaryElement()
  {
      hexBinaryElement_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[0].get();
    if(fsm_p) 
    {
      XsdFSM&lt;hexBinaryElement_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;hexBinaryElement_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "hexBinaryElement", "{http://www.w3.org/2002/ws/databinding/examples/6/05/}hexBinaryElement", 1);
    return node_p;
        
  }
  
  
  void echoHexBinaryElement::sequence::set_hexBinaryElement(DOMString val)
  {
      
    element_hexBinaryElement()-&gt;stringValue(val);
  }

  DOMString echoHexBinaryElement::sequence::get_hexBinaryElement_string()
  {
    return element_hexBinaryElement()-&gt;stringValue();
  }

      
} // end namespace      
    </pre>
</div>
<br><br>
<h3><a name="examples_netEnabled_src_examples_6_05_echo.cpp">examples/netEnabled/src/examples_6_05/echo.cpp</a></h3>
<div style="border:1px dotted black; padding:0em; background-color:#E6E6FA;">
<pre>

 //
 //  This file was automatically generated using XmlPlus xsd2cpp tool.
 //  Please do not edit.
 //
  
#include "examples_6_05/echo.h"

namespace examples_6_05{


  //constructor
  
  echo::echo(ElementCreateArgs args):
      XMLSchema::XmlElement&lt;anyType&gt;(args),
    
    _fsmElems(NULL),
    _fsmAttrs(NULL)
  
    , _sequence(new sequence(this) )
  
  {
    this-&gt;contentTypeVariety(CONTENT_TYPE_VARIETY_ELEMENT_ONLY);
    initFSM();
    if(args.ownerDoc && args.ownerDoc-&gt;buildTree())
    {
      if(args.ownerDoc-&gt;createSample()) {
        _fsm-&gt;fireSampleEvents();
      }
      else {
        _fsm-&gt;fireRequiredEvents();
      }
    }
  }
    
  void echo::initFSM()
  {
    XsdFsmBasePtr fsmsAttrs[] = {
  
      NULL
    };

    _fsm-&gt;replaceOrAppendUniqueAttributeFsms(fsmsAttrs);
  
    _fsm-&gt;replaceContentFsm(_sequence);
      
    _fsmAttrs = _fsm-&gt;attributeFsm();
    _fsmElems = _fsm-&gt;contentFsm();

  }

  /* element functions  */
  

  echoHexBinaryElement_ptr echo::create_echoHexBinaryElement(FsmCbOptions& options)
  {
    static DOMStringPtr myName = new DOMString("echoHexBinaryElement");
    static DOMStringPtr myNsUri = new DOMString("http://www.w3.org/2002/ws/databinding/examples/6/05/");
    
    XSD::StructCreateElementThroughFsm t( myName, myNsUri, NULL, this-&gt;ownerElement(), this-&gt;ownerDocument(), _fsm, options, false, false, false);
    echoHexBinaryElement_p node = XSD::createElementTmpl&lt;echoHexBinaryElement, void*&gt;(t);
          
    _echoHexBinaryElement = node;
      
    return node;
  }

  
  echoHexBinaryElement_p echo::element_echoHexBinaryElement()
  {
    FSM::warnNullNode(_echoHexBinaryElement, "echoHexBinaryElement", "{http://www.w3.org/2002/ws/databinding/examples/6/05/}echoHexBinaryElement", 1);
    return _echoHexBinaryElement;
  }
      

  /* attribute  functions  */
  
  //constructor
  echo::sequence::sequence(echo* that):
    _that(that)
  {
    XsdFsmBasePtr fsmArray[] = {
    new XsdFSM&lt;echoHexBinaryElement_ptr&gt;( Particle(new DOMString("http://www.w3.org/2002/ws/databinding/examples/6/05/"), DOMString("echoHexBinaryElement"), 1, 1), XsdEvent::ELEMENT_START, new object_unary_mem_fun_t&lt;echoHexBinaryElement_ptr, echo, FsmCbOptions&gt;(_that, &echo::create_echoHexBinaryElement)),
             
      NULL 
    } ;
    
    XsdSequenceFsmOfFSMs::init(fsmArray);
  }

      

  echoHexBinaryElement_p echo::sequence::element_echoHexBinaryElement()
  {
      echoHexBinaryElement_p node_p = NULL;
    XsdFsmBase* fsm_p = this-&gt;allFSMs()[0].get();
    if(fsm_p) 
    {
      XsdFSM&lt;echoHexBinaryElement_ptr&gt; *unitFsm = dynamic_cast&lt;XsdFSM&lt;echoHexBinaryElement_ptr&gt; *&gt;(fsm_p);
      if(unitFsm && unitFsm-&gt;nodeList().size()&gt;0) {
        assert(unitFsm-&gt;nodeList().size()==1);  
        node_p = unitFsm-&gt;nodeList().at(0); 
      }
    }
    
    FSM::warnNullNode(node_p, "echoHexBinaryElement", "{http://www.w3.org/2002/ws/databinding/examples/6/05/}echoHexBinaryElement", 1);
    return node_p;
        
  }
  
  
} // end namespace      
    </pre>
</div>
<br><br>
<br>
</form></body></html>
